Loading
  540 tests found

Running tests
  Running ASHR1/test.desc  [OK]
  Running Address_of1/test.desc  [OK]
  Running Address_of2/test.desc  [OK]
  Running Anonymous_Struct1/test.desc  [OK]
  Running Anonymous_Struct2/test.desc  [OK]
  Running Anonymous_Struct3/test.desc  [OK]
  Running Array_Initialization1/test.desc  [OK]
  Running Array_Initialization2/test.desc  [OK]
  Running Array_Initialization3/test.desc  [OK]
  Running Array_operations1/test.desc  [FAILED]
  Running Associativity1/test.desc  [OK]
  Running Assumption1/test.desc  [OK]
  Running BV_Arithmetic1/test.desc  [OK]
  Running BV_Arithmetic2/test.desc  [OK]
  Running BV_Arithmetic3/test.desc  [OK]
  Running BV_Arithmetic4/test.desc  [OK]
  Running BV_Arithmetic5/test.desc  [OK]
  Running BV_Arithmetic6/test.desc  [OK]
  Running Bitfields1/test.desc  [OK]
  Running Bitfields2/test.desc  [OK]
  Running Bitfields3/test.desc  [OK]
  Running Bool1/test.desc  [OK]
  Running Bool2/test.desc  [OK]
  Running Bool3/test.desc  [OK]
  Running Bool4/test.desc  [OK]
  Running Boolean_Guards1/test.desc  [OK]
  Running Calloc1/test.desc  [OK]
  Running Computed-Goto1/test.desc  [OK]
  Running Division1/test.desc  [OK]
  Running Division2/test.desc  [OK]
  Running Double-to-float-no-simp1/test.desc  [OK]
  Running Double-to-float-no-simp1-fix1/test.desc  [OK]
  Running Double-to-float-no-simp1-fix2/test.desc  [OK]
  Running Double-to-float-with-simp1/test.desc  [OK]
  Running Ellipsis1/test.desc  [OK]
  Running Ellipsis2/test.desc  [OK]
  Running Empty_struct1/test.desc  [OK]
  Running Endianness1/test.desc  [OK]
  Running Endianness2/test.desc  [OK]
  Running Endianness3/test.desc  [OK]
  Running Endianness4/test.desc  [OK]
  Running Endianness5/test.desc  [OK]
  Running Endianness6/test.desc  [OK]
  Running Endianness7/test.desc  [OK]
  Running Endianness8/test.desc  [OK]
  Running Endianness9/test.desc  [OK]
  Running Error_Label1/test.desc  [OK]
  Running Error_Label2/test.desc  [OK]
  Running Error_Label3/test.desc  [OK]
  Running Eval_Order1/test.desc  [OK]
  Running Eval_Order2/test.desc  [SKIPPED]
  Running Exceptions1/test.desc  [OK]
  Running Failing_Assert1/test.desc  [OK]
  Running Fixedbv1/test.desc  [OK]
  Running Fixedbv2/test.desc  [OK]
  Running Fixedbv3/test.desc  [OK]
  Running Fixedbv4/test.desc  [OK]
  Running Fixedbv5/test.desc  [OK]
  Running Fixedbv6/test.desc  [OK]
  Running Fixedbv7/test.desc  [SKIPPED]
  Running Fixedbv8/test.desc  [OK]
  Running Float-Rounding1/test.desc  [OK]
  Running Float-Rounding2/test.desc  [OK]
  Running Float-Rounding3/test.desc  [OK]
  Running Float-data-dependent-rounding/test.desc  [OK]
  Running Float-div1/test.desc  [OK]
  Running Float-div1-refine/test.desc  [OK]
  Running Float-div2/test.desc  [OK]
  Running Float-div3/test.desc  [OK]
  Running Float-flags-no-simp1/test.desc  [OK]
  Running Float-flags-simp1/test.desc  [OK]
  Running Float-no-simp1/test.desc  [OK]
  Running Float-no-simp2/test.desc  [OK]
  Running Float-no-simp3/test.desc  [OK]
  Running Float-no-simp4/test.desc  [OK]
  Running Float-no-simp5/test.desc  [OK]
  Running Float-no-simp6/test.desc  [OK]
  Running Float-no-simp7/test.desc  [OK]
  Running Float-no-simp8/test.desc  [OK]
  Running Float-overflow1/test.desc  [OK]
  Running Float-overflow2/test.desc  [OK]
  Running Float-smt2-1/test.desc  [SKIPPED]
  Running Float-to-double1/test.desc  [OK]
  Running Float-to-double2/test.desc  [OK]
  Running Float-to-int1/test.desc  [OK]
  Running Float-to-int2/test.desc  [OK]
  Running Float-to-int3/test.desc  [OK]
  Running Float-zero-sum1/test.desc  [OK]
  Running Float1/test.desc  [OK]
  Running Float11/test.desc  [OK]
  Running Float12/test.desc  [OK]
  Running Float13/test.desc  [OK]
  Running Float14/test.desc  [OK]
  Running Float18/test.desc  [OK]
  Running Float19/test.desc  [OK]
  Running Float2/test.desc  [OK]
  Running Float20/test.desc  [OK]
  Running Float21/test.desc  [OK]
  Running Float22/test.desc  [OK]
  Running Float23/test.desc  [OK]
  Running Float24/test.desc  [FAILED]
  Running Float3/test.desc  [OK]
  Running Float4/test.desc  [OK]
  Running Float5/test.desc  [OK]
  Running Float6/test.desc  [OK]
  Running Float7/test.desc  [OK]
  Running Float8/test.desc  [OK]
  Running Float_lib1/test.desc  [OK]
  Running Float_lib2/test.desc  [OK]
  Running Free1/test.desc  [OK]
  Running Free2/test.desc  [OK]
  Running Free3/test.desc  [OK]
  Running Free4/test.desc  [OK]
  Running Function-KnR1/test.desc  [OK]
  Running Function1/test.desc  [OK]
  Running Function10/test.desc  [OK]
  Running Function11/test.desc  [OK]
  Running Function12/test.desc  [OK]
  Running Function13/test.desc  [OK]
  Running Function2/test.desc  [OK]
  Running Function3/test.desc  [OK]
  Running Function4/test.desc  [OK]
  Running Function5/test.desc  [OK]
  Running Function6/test.desc  [OK]
  Running Function7/test.desc  [OK]
  Running Function8/test.desc  [OK]
  Running Function9/test.desc  [OK]
  Running Function_Eval_Order1/test.desc  [SKIPPED]
  Running Function_Eval_Order2/test.desc  [OK]
  Running Function_Parameters1/test.desc  [SKIPPED]
  Running Function_Pointer1/test.desc  [OK]
  Running Function_Pointer10/test.desc  [OK]
  Running Function_Pointer11/test.desc  [OK]
  Running Function_Pointer12/test.desc  [OK]
  Running Function_Pointer13/test.desc  [OK]
  Running Function_Pointer14/test.desc  [OK]
  Running Function_Pointer15/test.desc  [OK]
  Running Function_Pointer16/test.desc  [OK]
  Running Function_Pointer17/test.desc  [OK]
  Running Function_Pointer2/test.desc  [OK]
  Running Function_Pointer3/test.desc  [OK]
  Running Function_Pointer4/test.desc  [OK]
  Running Function_Pointer5/test.desc  [OK]
  Running Function_Pointer6/test.desc  [OK]
  Running Function_Pointer7/test.desc  [OK]
  Running Function_Pointer8/test.desc  [OK]
  Running Function_Pointer9/test.desc  [OK]
  Running Global_Initialization1/test.desc  [OK]
  Running Global_Initialization2/test.desc  [OK]
  Running Initialization1/test.desc  [OK]
  Running Initialization2/test.desc  [OK]
  Running Initialization3/test.desc  [OK]
  Running Initialization5/test.desc  [OK]
  Running Initialization6/test.desc  [OK]
  Running Initialization7/test.desc  [SKIPPED]
  Running Linking1/test.desc  [OK]
  Running Linking2/test.desc  [OK]
  Running Linking3/test.desc  [OK]
  Running Linking4/test.desc  [OK]
  Running Linking5/test.desc  [OK]
  Running Linking6/test.desc  [OK]
  Running Linking7/member-name-mismatch.desc  [SKIPPED]
  Running Linking7/test.desc  [FAILED]
  Running Local_out_of_scope1/test.desc  [OK]
  Running Local_out_of_scope2/test.desc  [OK]
  Running Local_out_of_scope3/test.desc  [FAILED]
  Running Malloc12/test.desc  [SKIPPED]
  Running Malloc13/test.desc  [SKIPPED]
  Running Malloc14/test.desc  [OK]
  Running Malloc15/test.desc  [OK]
  Running Malloc16/test.desc  [OK]
  Running Malloc17/test.desc  [OK]
  Running Malloc18/test.desc  [OK]
  Running Malloc19/test.desc  [OK]
  Running Malloc20/test.desc  [OK]
  Running Malloc21/test.desc  [OK]
  Running Malloc22/test.desc  [FAILED]
  Running Malloc23/test.desc  [OK]
  Running Malloc24/test.desc  [OK]
  Running Memmove1/test.desc  [FAILED]
  Running Memory_leak1/test.desc  [OK]
  Running Memory_leak2/test.desc  [OK]
  Running Mod1/test.desc  [OK]
  Running Mod2/test.desc  [OK]
  Running Multi_Dimensional_Array1/test.desc  [OK]
  Running Multi_Dimensional_Array2/test.desc  [FAILED]
  Running Multi_Dimensional_Array3/test.desc  [OK]
  Running Multi_Dimensional_Array4/test.desc  [OK]
  Running Multi_Dimensional_Array5/test.desc  [OK]
  Running Multi_Dimensional_Array6/test.desc  [FAILED]
  Running Multiple_Properties1/test.desc  [OK]
  Running Negation1/test.desc  [OK]
  Running Negation2/test.desc  [OK]
  Running Overflow_Addition1/test.desc  [OK]
  Running Overflow_Leftshift1/test.desc  [OK]
  Running Overflow_Multiplication1/test.desc  [OK]
  Running Overflow_Subtraction1/test.desc  [OK]
  Running Pointer_Arithmetic1/test.desc  [OK]
  Running Pointer_Arithmetic10/test.desc  [OK]
  Running Pointer_Arithmetic11/test.desc  [OK]
  Running Pointer_Arithmetic12/test.desc  [FAILED]
  Running Pointer_Arithmetic13/test.desc  [SKIPPED]
  Running Pointer_Arithmetic2/test.desc  [OK]
  Running Pointer_Arithmetic3/test.desc  [OK]
  Running Pointer_Arithmetic4/test.desc  [OK]
  Running Pointer_Arithmetic5/test.desc  [OK]
  Running Pointer_Arithmetic6/test.desc  [OK]
  Running Pointer_Arithmetic7/test.desc  [OK]
  Running Pointer_Arithmetic8/test.desc  [OK]
  Running Pointer_Arithmetic9/test.desc  [OK]
  Running Pointer_Assume1/test.desc  [SKIPPED]
  Running Pointer_array1/test.desc  [OK]
  Running Pointer_array2/test.desc  [OK]
  Running Pointer_array3/test.desc  [OK]
  Running Pointer_array4/test.desc  [OK]
  Running Pointer_array5/test.desc  [OK]
  Running Pointer_array6/test.desc  [OK]
  Running Pointer_byte_extract1/test.desc  [OK]
  Running Pointer_byte_extract2/test.desc  [FAILED]
  Running Pointer_byte_extract3/test.desc  [OK]
  Running Pointer_byte_extract4/test.desc  [FAILED]
  Running Pointer_byte_extract5/no-simplify.desc  [OK]
  Running Pointer_byte_extract5/test.desc  [FAILED]
  Running Pointer_byte_extract6/test.desc  [OK]
  Running Pointer_byte_extract7/test.desc  [OK]
  Running Pointer_byte_extract8/test.desc  [SKIPPED]
  Running Pointer_byte_extract9/test.desc  [OK]
  Running Pointer_difference1/test.desc  [OK]
  Running Promotion1/test.desc  [OK]
  Running Promotion2/test.desc  [OK]
  Running Promotion3/test.desc  [OK]
  Running Promotion4/test.desc  [OK]
  Running Quantifiers-assertion/test.desc  [FAILED]
  Running Quantifiers-assignment/test.desc  [OK]
  Running Quantifiers-copy/test.desc  [OK]
  Running Quantifiers-if/test.desc  [OK]
  Running Quantifiers-initialisation/test.desc  [OK]
  Running Quantifiers-initialisation2/test.desc  [FAILED]
  Running Quantifiers-invalid-var-range/test.desc  [FAILED]
  Running Quantifiers-not/test.desc  [OK]
  Running Quantifiers-not-exists/test.desc  [FAILED]
  Running Quantifiers-two-dimension-array/test.desc  [OK]
  Running Quantifiers-type/test.desc  [OK]
  Running Quantifiers1/test.desc  [FAILED]
  Running Recursion1/test.desc  [OK]
  Running Recursion2/test.desc  [OK]
  Running Recursion3/test.desc  [OK]
  Running Recursion4/test.desc  [OK]
  Running Recursion5/test.desc  [OK]
  Running Recursion6/test.desc  [FAILED]
  Running Sideeffects1/test.desc  [OK]
  Running Sideeffects2/test.desc  [OK]
  Running Sideeffects3/test.desc  [OK]
  Running Sideeffects4/test.desc  [OK]
  Running Sideeffects5/test.desc  [OK]
  Running Sideeffects6/test.desc  [OK]
  Running Static2/test.desc  [OK]
  Running Static4/test.desc  [OK]
  Running Static_Functions1/test.desc  [OK]
  Running String1/test.desc  [OK]
  Running String2/test.desc  [OK]
  Running String3/test.desc  [SKIPPED]
  Running String4/test.desc  [OK]
  Running String5/test.desc  [OK]
  Running String6/test.desc  [OK]
  Running String7/test.desc  [OK]
  Running String_Literal1/test.desc  [OK]
  Running Struct_Bytewise1/test.desc  [OK]
  Running Struct_Bytewise2/test.desc  [OK]
  Running Struct_Initialization1/test.desc  [OK]
  Running Struct_Initialization10/test.desc  [OK]
  Running Struct_Initialization2/test.desc  [OK]
  Running Struct_Initialization3/test.desc  [OK]
  Running Struct_Initialization4/test.desc  [OK]
  Running Struct_Initialization5/test.desc  [OK]
  Running Struct_Initialization6/test.desc  [OK]
  Running Struct_Initialization7/test.desc  [OK]
  Running Struct_Initialization8/test.desc  [SKIPPED]
  Running Struct_Initialization9/test.desc  [OK]
  Running Struct_Padding1/test.desc  [OK]
  Running Typecast1/test.desc  [OK]
  Running Typecast2/test.desc  [OK]
  Running Undefined_Function1/test.desc  [FAILED]
  Running Undefined_Function2/test.desc  [FAILED]
  Running Undefined_Shift1/test.desc  [OK]
  Running Union_Initialization1/test.desc  [OK]
  Running Unwinding_Assertions_Improved1/test.desc  [SKIPPED]
  Running Unwinding_Locality1/test.desc  [OK]
  Running Variadic1/test.desc  [SKIPPED]
  Running Visual_Studio_Types1/test.desc  [OK]
  Running Visual_Studio_Types2/test.desc  [OK]
  Running Volatile1/test.desc  [SKIPPED]
  Running Zero_Initialization1/test.desc  [OK]
  Running __func__1/test.desc  [OK]
  Running abs1/test.desc  [OK]
  Running address_space_size_limit1/test.desc  [FAILED]
  Running address_space_size_limit2/test.desc  [SKIPPED]
  Running address_space_size_limit3/test.desc  [OK]
  Running always_inline1/test.desc  [OK]
  Running always_inline2/test.desc  [OK]
  Running always_inline3/test.desc  [OK]
  Running argv1/test.descbash: line 1: 97154 Abort trap: 6           symex --bounds-check --pointer-check 'main.c' > 'test.out' 2>&1
  [FAILED]
  Running atomic_section_seq1/test.desc  [OK]
  Running bad_option/test.desc  [OK]
  Running bad_option/test_multiple.desc  [OK]
  Running big-endian-array1/test.desc  [FAILED]
  Running bounds_check1/test.desc  [OK]
  Running byte_update1/test.desc  [OK]
  Running byte_update2/test.desc  [FAILED]
  Running byte_update3/test.desc  [FAILED]
  Running byte_update4/test.desc  [FAILED]
  Running byte_update5/test.desc  [FAILED]
  Running byte_update6/test.desc  [FAILED]
  Running byte_update7/test.desc  [FAILED]
  Running byte_update8/test.desc  [OK]
  Running byte_update9/test.desc  [OK]
  Running c99_Bool/test.desc  [OK]
  Running char1/test.desc  [OK]
  Running character_handling1/test.desc  [OK]
  Running comma1/test.desc  [OK]
  Running complex1/test.desc  [OK]
  Running compound_literal1/test.desc  [OK]
  Running const_ptr1/test.desc  [OK]
  Running constant_folding1/test.desc  [OK]
  Running constant_folding2/test.desc  [SKIPPED]
  Running constructor1/test.desc  [OK]
  Running coverage_report1/test.desc  [FAILED]
  Running cpp1/test.desc  [SKIPPED]
  Running cpp2/test.desc  [SKIPPED]
  Running divide-by-one-simplify/test.desc  [OK]
  Running dynamic_size1/test.desc  [OK]
  Running dynamic_sizeof1/test.desc  [OK]
  Running enum1/test.desc  [OK]
  Running enum2/test.desc  [OK]
  Running enum3/test.desc  [OK]
  Running enum4/test.desc  [OK]
  Running enum5/test.desc  [OK]
  Running enum6/test.desc  [SKIPPED]
  Running equality_through_array1/test.desc  [OK]
  Running equality_through_array2/test.desc  [OK]
  Running equality_through_array3/test.desc  [OK]
  Running equality_through_array4/test.desc  [OK]
  Running equality_through_array5/test.desc  [OK]
  Running equality_through_array6/test.desc  [OK]
  Running equality_through_array_of_struct1/test.desc  [OK]
  Running equality_through_array_of_struct2/test.desc  [OK]
  Running equality_through_array_of_struct3/test.desc  [OK]
  Running equality_through_array_of_struct4/test.desc  [OK]
  Running equality_through_struct1/test.desc  [OK]
  Running equality_through_struct2/test.desc  [OK]
  Running equality_through_struct3/test.desc  [OK]
  Running equality_through_struct4/test.desc  [OK]
  Running equality_through_struct5/test.desc  [OK]
  Running equality_through_struct_containing_arrays1/test.desc  [OK]
  Running equality_through_struct_containing_arrays2/test.desc  [OK]
  Running equality_through_struct_containing_arrays3/test.desc  [OK]
  Running equality_through_union1/test.desc  [OK]
  Running equality_through_union2/test.desc  [OK]
  Running equality_through_union3/test.desc  [OK]
  Running exit1/test.desc  [OK]
  Running extern1/test.desc  [OK]
  Running extern2/test.desc  [OK]
  Running extern_initialization1/test.desc  [OK]
  Running extern_initialization2/test.desc  [OK]
  Running fgets1/test.desc  [FAILED]
  Running for-break1/test.desc  [OK]
  Running for1/test.desc  [OK]
  Running for2/test.desc  [OK]
  Running for3/test.desc  [OK]
  Running full_slice1/test.desc  [FAILED]
  Running full_slice2/test.desc  [FAILED]
  Running function_option1/test.desc  [OK]
  Running gcc_attribute_alias1/test.desc  [OK]
  Running gcc_bswap1/test.desc  [OK]
  Running gcc_c99-bool-1/test.desc  [OK]
  Running gcc_conditional_expr1/test.desc  [OK]
  Running gcc_local_label1/test.desc  [FAILED]
  Running gcc_popcount1/test.desc  [OK]
  Running gcc_popcount2/test.desc  [SKIPPED]
  Running gcc_statement_expression1/test.desc  [OK]
  Running gcc_statement_expression2/test.desc  [OK]
  Running gcc_statement_expression3/test.desc  [OK]
  Running gcc_statement_expression4/test.desc  [OK]
  Running gcc_statement_expression5/test.desc  [OK]
  Running gcc_switch_case_range1/test.desc  [OK]
  Running gcc_switch_case_range2/test.desc  [OK]
  Running gcc_vector1/test.desc  [OK]
  Running gcc_vector2/test.desc  [OK]
  Running getenv-overflow1/test.desc  [OK]
  Running goto1/test.desc  [OK]
  Running goto2/test.desc  [OK]
  Running goto3/test.desc  [OK]
  Running goto4/test.desc  [FAILED]
  Running goto5/test.desc  [OK]
  Running graphml_witness1/test.desc  [FAILED]
  Running guard1/test.desc  [OK]
  Running havoc_object1/test.desc  [FAILED]
  Running hex_string1/test.desc  [OK]
  Running hex_trace/test.desc  [FAILED]
  Running if1/test.desc  [OK]
  Running if2/test.desc  [OK]
  Running if3/test.desc  [OK]
  Running if4/test.desc  [OK]
  Running inequality-with-constant-normalisation/test.desc  [OK]
  Running inet_endian1/test.desc  [OK]
  Running inline1/test.desc  [OK]
  Running int-to-float1/test.desc  [OK]
  Running int-to-float2/test.desc  [OK]
  Running integer-assignments1/test.desc  [SKIPPED]
  Running json1/test.descbash: line 1: 97697 Abort trap: 6           symex --json-ui --stop-on-fail 'main.c' > 'test.out' 2>&1
  [FAILED]
  Running little-endian-array1/test.desc  [FAILED]
  Running locations1/test.desc  [OK]
  Running memcpy1/test.desc  [OK]
  Running memcpy2/test.desc  [OK]
  Running memcpy3/test.desc  [OK]
  Running memory_allocation1/test.desc  [FAILED]
  Running memset1/test.desc  [FAILED]
  Running memset2/test.desc  [OK]
  Running memset3/test.desc  [FAILED]
  Running mm_io1/test.desc  [FAILED]
  Running no_nondet_static/test.desc  [FAILED]
  Running noop1/test.desc  [OK]
  Running null1/test.desc  [OK]
  Running null2/test.desc  [OK]
  Running null3/test.desc  [FAILED]
  Running offsetof1/test.desc  [FAILED]
  Running phi-merge_uninitialized_values/dynamic.desc  [OK]
  Running phi-merge_uninitialized_values/global.desc  [OK]
  Running phi-merge_uninitialized_values/local.desc  [OK]
  Running phi-merge_uninitialized_values/static_local.desc  [OK]
  Running pipe1/test.desc  [FAILED]
  Running pointer-extra-checks/test.desc  [OK]
  Running pointer-function-parameters/test.desc  [FAILED]
  Running pointer-function-parameters-2/test.desc  [FAILED]
  Running printf1/test.desc  [FAILED]
  Running reachability-slice/test.desc  [FAILED]
  Running reachability-slice/test2.desc  [FAILED]
  Running reachability-slice/test3.desc  [FAILED]
  Running reachability-slice-interproc/test.desc  [FAILED]
  Running read1/test.desc  [FAILED]
  Running realloc1/test.desc  [OK]
  Running realloc2/test.desc  [OK]
  Running realloc3/test.desc  [FAILED]
  Running return1/test.desc  [OK]
  Running return2/test.desc  [OK]
  Running return3/test.desc  [OK]
  Running return4/test.desc  [OK]
  Running return5/test.desc  [OK]
  Running return6/test.desc  [OK]
  Running scanf1/big-endian.desc  [SKIPPED]
  Running scanf1/no-simplify.desc  [SKIPPED]
  Running scanf1/test.desc  [OK]
  Running self_loops_to_assumptions1/default.desc  [FAILED]
  Running self_loops_to_assumptions1/no-assume.desc  [FAILED]
  Running simple_assert/test.desc  [OK]
  Running simplify-full-test/test.desc  [OK]
  Running simplify-function-call-array-element-pointer/test.desc  [OK]
  Running simplify-function-call-array-pointer/test.desc  [OK]
  Running simplify-function-call-pointer-access/test.desc  [OK]
  Running simplify-global-array-access/test.desc  [OK]
  Running simplify-local-array-access/test.desc  [OK]
  Running simplify-pointer-access/test.desc  [OK]
  Running strcat1/test.desc  [FAILED]
  Running strchr1/test.desc  [OK]
  Running strtol1/test.desc  [OK]
  Running strtol2/test.desc  [OK]
  Running struct1/test.desc  [OK]
  Running struct3/test.desc  [OK]
  Running struct4/test.desc  [OK]
  Running struct6/test.desc  [OK]
  Running struct7/test.desc  [OK]
  Running struct8/test.desc  [OK]
  Running struct9/test.desc  [OK]
  Running switch1/test.desc  [OK]
  Running switch2/test.desc  [OK]
  Running switch3/test.desc  [OK]
  Running switch4/test.desc  [OK]
  Running switch5/test.desc  [OK]
  Running switch6/test.desc  [OK]
  Running switch7/test.desc  [OK]
  Running symex_should_exclude_null_pointers/test.desc  [FAILED]
  Running trace_options_json_extended/extended.desc  [FAILED]
  Running trace_options_json_extended/non-extended.descbash: line 1: 98109 Abort trap: 6           symex --trace --json-ui 'test.c' > 'non-extended.out' 2>&1
  [FAILED]
  Running trace_show_code/test.desc  [FAILED]
  Running trace_show_function_calls/test.desc  [FAILED]
  Running ts18661_typedefs/test.desc  [OK]
  Running typedef-anon-struct1/test.desc  [OK]
  Running typedef-anon-struct2/test.desc  [OK]
  Running typedef-anon-union1/test.desc  [OK]
  Running typedef-anon-union2/test.desc  [OK]
  Running typedef-const-struct1/test.desc  [OK]
  Running typedef-const-type1/test.desc  [OK]
  Running typedef-const-union1/test.desc  [OK]
  Running typedef-param-anon-struct1/test.desc  [OK]
  Running typedef-param-anon-union1/test.desc  [OK]
  Running typedef-param-struct1/test.desc  [OK]
  Running typedef-param-type1/test.desc  [OK]
  Running typedef-param-type2/test.desc  [OK]
  Running typedef-param-type3/test.desc  [OK]
  Running typedef-param-union1/test.desc  [OK]
  Running typedef-return-anon-struct1/test.desc  [OK]
  Running typedef-return-anon-union1/test.desc  [OK]
  Running typedef-return-struct1/test.desc  [OK]
  Running typedef-return-type1/test.desc  [OK]
  Running typedef-return-type2/test.desc  [OK]
  Running typedef-return-type3/test.desc  [OK]
  Running typedef-return-union1/test.desc  [OK]
  Running typedef-struct1/test.desc  [OK]
  Running typedef-struct2/test.desc  [OK]
  Running typedef-type1/test.desc  [OK]
  Running typedef-type2/test.desc  [OK]
  Running typedef-type3/test.desc  [OK]
  Running typedef-type4/test.desc  [OK]
  Running typedef-union1/test.desc  [OK]
  Running typedef-union2/test.desc  [OK]
  Running uncaught_exceptions_analysis1/test.desc  [OK]
  Running union1/test.desc  [SKIPPED]
  Running union2/test.desc  [OK]
  Running union3/test.desc  [OK]
  Running union4/test.desc  [OK]
  Running union5/test.desc  [OK]
  Running union6/test.desc  [OK]
  Running union7/test.desc  [OK]
  Running union8/test.desc  [OK]
  Running union9/test.desc  [OK]
  Running unsigned1/test.desc  [OK]
  Running unsigned___int128/test.desc  [OK]
  Running unsigned_char1/test.desc  [OK]
  Running unwind_counters1/test.desc  [FAILED]
  Running unwind_counters2/test.desc  [OK]
  Running unwind_counters3/test.desc  [OK]
  Running va_list1/test.desc  [OK]
  Running va_list2/test.desc  [SKIPPED]
  Running va_list3/test.desc  [SKIPPED]
  Running variable-access-to-constant-array/test.descbash: line 1: 98351 Segmentation fault: 11  symex 'main.c' > 'test.out' 2>&1
  [FAILED]
  Running void_ifthenelse/test.desc  [OK]
  Running void_pointer1/test.desc  [OK]
  Running void_pointer2/test.desc  [OK]
  Running void_pointer3/test.desc  [OK]
  Running while1/test.desc  [OK]

[31mTests failed[0m
  67 of 540 tests failed, 29 tests skipped


Failed test: Array_operations1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
unexpected OTHER statement: array_equal
Number of visited locations: 21 (out of 71)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.00253606s
Runtime decision procedure: 0s

** Results:
[test_equal.assertion.1] arrays are equal: SUCCESS
[test_copy.assertion.1] array1[10] is OK: SUCCESS
[test_copy.assertion.2] array1[99] is OK: SUCCESS
[test_copy.assertion.3] array1[10] is OK: SUCCESS
[test_copy.assertion.4] expected to fail: SUCCESS
[test_replace.assertion.1] array1[10] is OK: SUCCESS
[test_replace.assertion.2] array1[99] is OK: SUCCESS
[test_set.assertion.1] array1[44] is OK: SUCCESS

** 0 of 8 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^\[test_copy\.assertion\.4\] expected to fail: FAILURE$ [FAILED]
^\*\* 1 of 8 failed [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: Float24
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --xml-ui
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
VERIFICATION FAILED [FAILED]
<full_lhs_value>5\.1</full_lhs_value> [FAILED]


Failed test: Linking7
Parsing module.c
Parsing main.c
Converting
Type-checking main
Type-checking module
file module.c line 19: warning: non-pointer parameter types differ between declaration and definition "foo"
old definition
void (struct S)
new definition
void (struct real_S g)
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
file module.c line 31 function bar: replacing function pointer by 1 possible targets
Starting symbolic simulation
failed to dereference `symbol'
Number of visited locations: 25 (out of 36)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 0 remaining after simplification
Runtime total: 0.000754731s
Runtime decision procedure: 6.94728e-310s

** Results:
[foo.assertion.1] assertion *g.a == 42: SUCCESS
[foo.assertion.2] assertion *g.b == 41: SUCCESS

** 0 of 2 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]
^\*\* 1 of 2 failed [FAILED]


Failed test: Local_out_of_scope3
Parsing main.c
Converting
Type-checking main
file main.c line 20 function main: function `nondet_int' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
failed to dereference `symbol'
failed to dereference `symbol'
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
105 variables, 0 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Number of visited locations: 31 (out of 32)
Number of dropped states: 2
Number of paths: 1
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.000982104s
Runtime decision procedure: 0.000302766s

** Results:
[main.assertion.1] : SUCCESS

** 0 of 1 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: Malloc22
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
11163 variables, 33382 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
5125 variables, 10677 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
4998 variables, 10389 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 56 (out of 67)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 3 VCC(s), 3 remaining after simplification
Runtime total: 0.115609s
Runtime decision procedure: 0.104044s

** Results:
[main.assertion.1] assertion p[n-1] == n-1: FAILURE
[main.assertion.2] assertion pA[n-1] == n-1: FAILURE
[main.assertion.3] assertion 0: FAILURE

** 3 of 3 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]


Failed test: Memmove1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12277 variables, 23128 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 57 (out of 108)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.0579497s
Runtime decision procedure: 0.0537215s

** Results:
[main.assertion.1] assertion a[0]==-2147483600: FAILURE
[sort_items_by_criteria.precondition_instance.1] memmove source region readable: SUCCESS
[sort_items_by_criteria.precondition_instance.2] memmove destination region writeable: SUCCESS

** 1 of 3 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: Multi_Dimensional_Array2
Parsing main.c
Converting
Type-checking main
file main.c line 12 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1817 variables, 3905 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 24 (out of 33)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00863298s
Runtime decision procedure: 0.00608006s

** Results:
[main.assertion.1] assertion array[(signed long int)a][(signed long int)a] >= 0: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: Multi_Dimensional_Array6
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
unexpected array index on lhs
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
854 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 252 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
821 variables, 1670 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 391 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 318 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 458 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 1177 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 389 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 391 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 318 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 757 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 450 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 460 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 387 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 452 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 389 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 459 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 746 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 688 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 683 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 252 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 391 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 318 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 458 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 1357 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 1188 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
854 variables, 937 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 762 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 573 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected array index on lhs
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
854 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
821 variables, 1670 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 1297 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 1357 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
853 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
884 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
917 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
854 variables, 937 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 937 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 375 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 872 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 762 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 573 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
722 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 1370 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 1370 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 935 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 1370 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
886 variables, 1370 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 935 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 995 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
753 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
784 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
817 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 937 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
flatten_byte_update can only do arrays of scalars right now, but got array
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
786 variables, 937 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 375 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 627 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 696 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 756 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
589 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 762 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 573 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
589 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
556 variables, 252 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
589 variables, 381 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 504 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 573 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 510 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
589 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
622 variables, 384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 636 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
620 variables, 249 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 378 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
684 variables, 501 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
717 variables, 570 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
686 variables, 507 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
653 variables, 255 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Number of visited locations: 62 (out of 62)
Number of dropped states: 848
Number of paths: 1125
Number of infeasible paths: 0
Generated 858 VCC(s), 564 remaining after simplification
Runtime total: 0.573689s
Runtime decision procedure: 0.391459s

** Results:
[main.assertion.1] : SUCCESS
[main.assertion.2] : FAILURE

** 1 of 2 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\* 1 of 2 failed  [FAILED]


Failed test: Pointer_Arithmetic12
Parsing main.i
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1583 variables, 3553 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 127 (out of 138)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00888912s
Runtime decision procedure: 0.00504102s

** Results:
[main.assertion.1] : FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: Pointer_byte_extract2
Parsing main.c
Converting
Type-checking main
file main.c line 10 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
232 variables, 0 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
233 variables, 36 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 34 (out of 34)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 2 VCC(s), 2 remaining after simplification
Runtime total: 0.0019104s
Runtime decision procedure: 0.00116297s

** Results:
[main.assertion.1] assertion (signed int)(char)*pi == 50: SUCCESS
[main.assertion.2] assertion *pi == (unsigned int)50: FAILURE

** 1 of 2 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\* 1 of 2 failed  [FAILED]


Failed test: Pointer_byte_extract4
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  * #source_location: 
    * file: main.c
    * line: 50
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  0: member
      * type: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * component_name: linkage
      * #source_location: 
        * file: main.c
        * line: 50
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-node
              * #source_location: 
                * file: main.c
                * line: 50
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1100 variables, 938 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  * #source_location: 
    * file: main.c
    * line: 50
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  0: member
      * type: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * component_name: linkage
      * #source_location: 
        * file: main.c
        * line: 50
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-node
              * #source_location: 
                * file: main.c
                * line: 50
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1099 variables, 870 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  * #source_location: 
    * file: main.c
    * line: 50
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  0: member
      * type: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * component_name: linkage
      * #source_location: 
        * file: main.c
        * line: 50
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-node
              * #source_location: 
                * file: main.c
                * line: 50
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1099 variables, 870 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
failed to dereference `symbol'
Checking property main.assertion.2
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  * #source_location: 
    * file: main.c
    * line: 50
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  0: member
      * type: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * component_name: linkage
      * #source_location: 
        * file: main.c
        * line: 50
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-node
              * #source_location: 
                * file: main.c
                * line: 50
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
894 variables, 861 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  * #source_location: 
    * file: main.c
    * line: 50
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
  0: member
      * type: symbol
          * identifier: tag-list_head
          * #source_location: 
            * file: main.c
            * line: 11
            * function: 
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * component_name: linkage
      * #source_location: 
        * file: main.c
        * line: 50
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-node
              * #source_location: 
                * file: main.c
                * line: 50
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Pointer_byte_extract4
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
894 variables, 861 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
failed to dereference `symbol'
Number of visited locations: 64 (out of 85)
Number of dropped states: 2
Number of paths: 0
Number of infeasible paths: 0
Generated 8 VCC(s), 5 remaining after simplification
Runtime total: 0.00894613s
Runtime decision procedure: 0.00657811s

** Results:
[main.assertion.1] : FAILURE
[main.assertion.2] : SUCCESS
[main.assertion.3] : SUCCESS
[main.assertion.4] : SUCCESS
[main.assertion.5] : SUCCESS

** 1 of 5 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^warning: ignoring [FAILED]


Failed test: Pointer_byte_extract5
Parsing main.i
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.array_bounds.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
236 variables, 0 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
268 variables, 64 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
268 variables, 64 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
268 variables, 64 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
268 variables, 64 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
269 variables, 66 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
300 variables, 128 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
301 variables, 130 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
300 variables, 128 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
300 variables, 128 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.array_bounds.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
300 variables, 139 clauses
SAT checker: instance is SATISFIABLE
unexpected array index on lhs
Number of visited locations: 56 (out of 65)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 11 VCC(s), 11 remaining after simplification
Runtime total: 0.00793396s
Runtime decision procedure: 0.00486258s

** Results:
[main.array_bounds.1] array.List dynamic object upper bound
[main.array_bounds.2] array.List dynamic object upper bound
[main.assertion.1] p->List[0].b==555: SUCCESS
[main.assertion.2] p->List[0].a==555: SUCCESS
[main.array_bounds.3] array.List dynamic object upper bound
[main.array_bounds.4] array.List upper bound
[main.array_bounds.5] array.List dynamic object upper bound
[main.array_bounds.6] array.List upper bound
[main.assertion.3] p->List[1].b==999: SUCCESS
[main.assertion.4] p->List[1].a==999: SUCCESS
[main.array_bounds.7] array.List dynamic object upper bound

** 1 of 11 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
\*\* 1 of 11 failed  [FAILED]


Failed test: Quantifiers-assertion
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 545 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 547 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 547 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 547 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 545 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
340 variables, 545 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 25 (out of 32)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 6 VCC(s), 6 remaining after simplification
Runtime total: 0.0127895s
Runtime decision procedure: 0.010154s

** Results:
[main.assertion.1] Exists-Exists: successful: FAILURE
[main.assertion.2] NotExists-NotExists: successful: FAILURE
[main.assertion.3] NotExists-Exists: failed: FAILURE
[main.assertion.4] NotExists-Forall: failed: FAILURE
[main.assertion.5] NotForall-Forall: successful: FAILURE
[main.assertion.6] NotForall-NotForall: successful: FAILURE

** 6 of 6 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\[main.assertion.1\] Exists-Exists: successful: SUCCESS$ [FAILED]
^\[main.assertion.2\] NotExists-NotExists: successful: SUCCESS$ [FAILED]
^\[main.assertion.5\] NotForall-Forall: successful: SUCCESS$ [FAILED]
^\[main.assertion.6\] NotForall-NotForall: successful: SUCCESS$ [FAILED]
^\*\* 2 of 6 failed [FAILED]


Failed test: Quantifiers-initialisation2
Parsing main.c
Converting
Type-checking main
file main.c line 13 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
warning: ignoring forall
  * type: bool
  * #source_location: 
    * file: main.c
    * line: 12
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
  0: symbol
      * type: unsignedbv
          * width: 32
          * #c_type: unsigned_int
      * identifier: main::1::4::i#0
      * #SSA_symbol: 1
      * #full_identifier: main::1::4::i
  1: or
      * type: bool
      * #source_location: 
        * file: main.c
        * line: 12
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
      0: >=
          * type: bool
          * #source_location: 
            * file: main.c
            * line: 12
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
          0: symbol
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              * identifier: main::1::4::i#0
              * #SSA_symbol: 1
              * #full_identifier: main::1::4::i
          1: constant
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              * value: 00000000000000000000000000001010
      1: and
          * type: bool
          * #source_location: 
            * file: main.c
            * line: 12
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
          0: if
              * type: bool
              0: =
                  * type: bool
                  0: typecast
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      0: symbol
                          * type: unsignedbv
                              * width: 32
                              * #c_type: unsigned_int
                          * identifier: main::1::4::i#0
                          * #SSA_symbol: 1
                          * #full_identifier: main::1::4::i
                  1: constant
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      * value: 0000000000000000000000000000000000000000000000000000000000001001
              1: >=
                  * type: bool
                  * #source_location: 
                    * file: main.c
                    * line: 12
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                  0: symbol
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * identifier: main::1::a[9]#1
                      * #SSA_symbol: 1
                      * #full_identifier: main::1::a[9]
                  1: constant
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * value: 00000000000000000000000000000001
                      * #source_location: 
                        * file: main.c
                        * line: 12
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                      * #base: 10
              2: if
                  * type: bool
                  0: =
                      * type: bool
                      0: typecast
                          * type: signedbv
                              * width: 64
                              * #c_type: signed_long_int
                          0: symbol
                              * type: unsignedbv
                                  * width: 32
                                  * #c_type: unsigned_int
                              * identifier: main::1::4::i#0
                              * #SSA_symbol: 1
                              * #full_identifier: main::1::4::i
                      1: constant
                          * type: signedbv
                              * width: 64
                              * #c_type: signed_long_int
                          * value: 0000000000000000000000000000000000000000000000000000000000001000
                  1: >=
                      * type: bool
                      * #source_location: 
                        * file: main.c
                        * line: 12
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                      0: symbol
                          * type: signedbv
                              * width: 32
                              * #c_type: signed_int
                          * identifier: main::1::a[8]#1
                          * #SSA_symbol: 1
                          * #full_identifier: main::1::a[8]
                      1: constant
                          * type: signedbv
                              * width: 32
                              * #c_type: signed_int
                          * value: 00000000000000000000000000000001
                          * #source_location: 
                            * file: main.c
                            * line: 12
                            * function: main
                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                          * #base: 10
                  2: if
                      * type: bool
                      0: =
                          * type: bool
                          0: typecast
                              * type: signedbv
                                  * width: 64
                                  * #c_type: signed_long_int
                              0: symbol
                                  * type: unsignedbv
                                      * width: 32
                                      * #c_type: unsigned_int
                                  * identifier: main::1::4::i#0
                                  * #SSA_symbol: 1
                                  * #full_identifier: main::1::4::i
                          1: constant
                              * type: signedbv
                                  * width: 64
                                  * #c_type: signed_long_int
                              * value: 0000000000000000000000000000000000000000000000000000000000000111
                      1: >=
                          * type: bool
                          * #source_location: 
                            * file: main.c
                            * line: 12
                            * function: main
                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                          0: symbol
                              * type: signedbv
                                  * width: 32
                                  * #c_type: signed_int
                              * identifier: main::1::a[7]#1
                              * #SSA_symbol: 1
                              * #full_identifier: main::1::a[7]
                          1: constant
                              * type: signedbv
                                  * width: 32
                                  * #c_type: signed_int
                              * value: 00000000000000000000000000000001
                              * #source_location: 
                                * file: main.c
                                * line: 12
                                * function: main
                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                              * #base: 10
                      2: if
                          * type: bool
                          0: =
                              * type: bool
                              0: typecast
                                  * type: signedbv
                                      * width: 64
                                      * #c_type: signed_long_int
                                  0: symbol
                                      * type: unsignedbv
                                          * width: 32
                                          * #c_type: unsigned_int
                                      * identifier: main::1::4::i#0
                                      * #SSA_symbol: 1
                                      * #full_identifier: main::1::4::i
                              1: constant
                                  * type: signedbv
                                      * width: 64
                                      * #c_type: signed_long_int
                                  * value: 0000000000000000000000000000000000000000000000000000000000000110
                          1: >=
                              * type: bool
                              * #source_location: 
                                * file: main.c
                                * line: 12
                                * function: main
                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                              0: symbol
                                  * type: signedbv
                                      * width: 32
                                      * #c_type: signed_int
                                  * identifier: main::1::a[6]#1
                                  * #SSA_symbol: 1
                                  * #full_identifier: main::1::a[6]
                              1: constant
                                  * type: signedbv
                                      * width: 32
                                      * #c_type: signed_int
                                  * value: 00000000000000000000000000000001
                                  * #source_location: 
                                    * file: main.c
                                    * line: 12
                                    * function: main
                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                  * #base: 10
                          2: if
                              * type: bool
                              0: =
                                  * type: bool
                                  0: typecast
                                      * type: signedbv
                                          * width: 64
                                          * #c_type: signed_long_int
                                      0: symbol
                                          * type: unsignedbv
                                              * width: 32
                                              * #c_type: unsigned_int
                                          * identifier: main::1::4::i#0
                                          * #SSA_symbol: 1
                                          * #full_identifier: main::1::4::i
                                  1: constant
                                      * type: signedbv
                                          * width: 64
                                          * #c_type: signed_long_int
                                      * value: 0000000000000000000000000000000000000000000000000000000000000101
                              1: >=
                                  * type: bool
                                  * #source_location: 
                                    * file: main.c
                                    * line: 12
                                    * function: main
                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                  0: symbol
                                      * type: signedbv
                                          * width: 32
                                          * #c_type: signed_int
                                      * identifier: main::1::a[5]#1
                                      * #SSA_symbol: 1
                                      * #full_identifier: main::1::a[5]
                                  1: constant
                                      * type: signedbv
                                          * width: 32
                                          * #c_type: signed_int
                                      * value: 00000000000000000000000000000001
                                      * #source_location: 
                                        * file: main.c
                                        * line: 12
                                        * function: main
                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                      * #base: 10
                              2: if
                                  * type: bool
                                  0: =
                                      * type: bool
                                      0: typecast
                                          * type: signedbv
                                              * width: 64
                                              * #c_type: signed_long_int
                                          0: symbol
                                              * type: unsignedbv
                                                  * width: 32
                                                  * #c_type: unsigned_int
                                              * identifier: main::1::4::i#0
                                              * #SSA_symbol: 1
                                              * #full_identifier: main::1::4::i
                                      1: constant
                                          * type: signedbv
                                              * width: 64
                                              * #c_type: signed_long_int
                                          * value: 0000000000000000000000000000000000000000000000000000000000000100
                                  1: >=
                                      * type: bool
                                      * #source_location: 
                                        * file: main.c
                                        * line: 12
                                        * function: main
                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                      0: symbol
                                          * type: signedbv
                                              * width: 32
                                              * #c_type: signed_int
                                          * identifier: main::1::a[4]#1
                                          * #SSA_symbol: 1
                                          * #full_identifier: main::1::a[4]
                                      1: constant
                                          * type: signedbv
                                              * width: 32
                                              * #c_type: signed_int
                                          * value: 00000000000000000000000000000001
                                          * #source_location: 
                                            * file: main.c
                                            * line: 12
                                            * function: main
                                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                          * #base: 10
                                  2: if
                                      * type: bool
                                      0: =
                                          * type: bool
                                          0: typecast
                                              * type: signedbv
                                                  * width: 64
                                                  * #c_type: signed_long_int
                                              0: symbol
                                                  * type: unsignedbv
                                                      * width: 32
                                                      * #c_type: unsigned_int
                                                  * identifier: main::1::4::i#0
                                                  * #SSA_symbol: 1
                                                  * #full_identifier: main::1::4::i
                                          1: constant
                                              * type: signedbv
                                                  * width: 64
                                                  * #c_type: signed_long_int
                                              * value: 0000000000000000000000000000000000000000000000000000000000000011
                                      1: >=
                                          * type: bool
                                          * #source_location: 
                                            * file: main.c
                                            * line: 12
                                            * function: main
                                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                          0: symbol
                                              * type: signedbv
                                                  * width: 32
                                                  * #c_type: signed_int
                                              * identifier: main::1::a[3]#1
                                              * #SSA_symbol: 1
                                              * #full_identifier: main::1::a[3]
                                          1: constant
                                              * type: signedbv
                                                  * width: 32
                                                  * #c_type: signed_int
                                              * value: 00000000000000000000000000000001
                                              * #source_location: 
                                                * file: main.c
                                                * line: 12
                                                * function: main
                                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                              * #base: 10
                                      2: if
                                          * type: bool
                                          0: =
                                              * type: bool
                                              0: typecast
                                                  * type: signedbv
                                                      * width: 64
                                                      * #c_type: signed_long_int
                                                  0: symbol
                                                      * type: unsignedbv
                                                          * width: 32
                                                          * #c_type: unsigned_int
                                                      * identifier: main::1::4::i#0
                                                      * #SSA_symbol: 1
                                                      * #full_identifier: main::1::4::i
                                              1: constant
                                                  * type: signedbv
                                                      * width: 64
                                                      * #c_type: signed_long_int
                                                  * value: 0000000000000000000000000000000000000000000000000000000000000010
                                          1: >=
                                              * type: bool
                                              * #source_location: 
                                                * file: main.c
                                                * line: 12
                                                * function: main
                                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                              0: symbol
                                                  * type: signedbv
                                                      * width: 32
                                                      * #c_type: signed_int
                                                  * identifier: main::1::a[2]#1
                                                  * #SSA_symbol: 1
                                                  * #full_identifier: main::1::a[2]
                                              1: constant
                                                  * type: signedbv
                                                      * width: 32
                                                      * #c_type: signed_int
                                                  * value: 00000000000000000000000000000001
                                                  * #source_location: 
                                                    * file: main.c
                                                    * line: 12
                                                    * function: main
                                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                  * #base: 10
                                          2: if
                                              * type: bool
                                              0: =
                                                  * type: bool
                                                  0: typecast
                                                      * type: signedbv
                                                          * width: 64
                                                          * #c_type: signed_long_int
                                                      0: symbol
                                                          * type: unsignedbv
                                                              * width: 32
                                                              * #c_type: unsigned_int
                                                          * identifier: main::1::4::i#0
                                                          * #SSA_symbol: 1
                                                          * #full_identifier: main::1::4::i
                                                  1: constant
                                                      * type: signedbv
                                                          * width: 64
                                                          * #c_type: signed_long_int
                                                      * value: 0000000000000000000000000000000000000000000000000000000000000001
                                              1: >=
                                                  * type: bool
                                                  * #source_location: 
                                                    * file: main.c
                                                    * line: 12
                                                    * function: main
                                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                  0: symbol
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * identifier: main::1::a[1]#1
                                                      * #SSA_symbol: 1
                                                      * #full_identifier: main::1::a[1]
                                                  1: constant
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * value: 00000000000000000000000000000001
                                                      * #source_location: 
                                                        * file: main.c
                                                        * line: 12
                                                        * function: main
                                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                      * #base: 10
                                              2: >=
                                                  * type: bool
                                                  * #source_location: 
                                                    * file: main.c
                                                    * line: 12
                                                    * function: main
                                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                  0: symbol
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * identifier: main::1::a[0]#1
                                                      * #SSA_symbol: 1
                                                      * #full_identifier: main::1::a[0]
                                                  1: constant
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * value: 00000000000000000000000000000001
                                                      * #source_location: 
                                                        * file: main.c
                                                        * line: 12
                                                        * function: main
                                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                      * #base: 10
          1: if
              * type: bool
              0: =
                  * type: bool
                  0: typecast
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      0: symbol
                          * type: unsignedbv
                              * width: 32
                              * #c_type: unsigned_int
                          * identifier: main::1::4::i#0
                          * #SSA_symbol: 1
                          * #full_identifier: main::1::4::i
                  1: constant
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      * value: 0000000000000000000000000000000000000000000000000000000000001001
              1: not
                  * type: bool
                  0: >=
                      * type: bool
                      * #source_location: 
                        * file: main.c
                        * line: 12
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                      0: symbol
                          * type: signedbv
                              * width: 32
                              * #c_type: signed_int
                          * identifier: main::1::a[9]#1
                          * #SSA_symbol: 1
                          * #full_identifier: main::1::a[9]
                      1: constant
                          * type: signedbv
                              * width: 32
                              * #c_type: signed_int
                          * value: 00000000000000000000000000001011
              2: if
                  * type: bool
                  0: =
                      * type: bool
                      0: typecast
                          * type: signedbv
                              * width: 64
                              * #c_type: signed_long_int
                          0: symbol
                              * type: unsignedbv
                                  * width: 32
                                  * #c_type: unsigned_int
                              * identifier: main::1::4::i#0
                              * #SSA_symbol: 1
                              * #full_identifier: main::1::4::i
                      1: constant
                          * type: signedbv
                              * width: 64
                              * #c_type: signed_long_int
                          * value: 0000000000000000000000000000000000000000000000000000000000001000
                  1: not
                      * type: bool
                      0: >=
                          * type: bool
                          * #source_location: 
                            * file: main.c
                            * line: 12
                            * function: main
                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                          0: symbol
                              * type: signedbv
                                  * width: 32
                                  * #c_type: signed_int
                              * identifier: main::1::a[8]#1
                              * #SSA_symbol: 1
                              * #full_identifier: main::1::a[8]
                          1: constant
                              * type: signedbv
                                  * width: 32
                                  * #c_type: signed_int
                              * value: 00000000000000000000000000001011
                  2: if
                      * type: bool
                      0: =
                          * type: bool
                          0: typecast
                              * type: signedbv
                                  * width: 64
                                  * #c_type: signed_long_int
                              0: symbol
                                  * type: unsignedbv
                                      * width: 32
                                      * #c_type: unsigned_int
                                  * identifier: main::1::4::i#0
                                  * #SSA_symbol: 1
                                  * #full_identifier: main::1::4::i
                          1: constant
                              * type: signedbv
                                  * width: 64
                                  * #c_type: signed_long_int
                              * value: 0000000000000000000000000000000000000000000000000000000000000111
                      1: not
                          * type: bool
                          0: >=
                              * type: bool
                              * #source_location: 
                                * file: main.c
                                * line: 12
                                * function: main
                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                              0: symbol
                                  * type: signedbv
                                      * width: 32
                                      * #c_type: signed_int
                                  * identifier: main::1::a[7]#1
                                  * #SSA_symbol: 1
                                  * #full_identifier: main::1::a[7]
                              1: constant
                                  * type: signedbv
                                      * width: 32
                                      * #c_type: signed_int
                                  * value: 00000000000000000000000000001011
                      2: if
                          * type: bool
                          0: =
                              * type: bool
                              0: typecast
                                  * type: signedbv
                                      * width: 64
                                      * #c_type: signed_long_int
                                  0: symbol
                                      * type: unsignedbv
                                          * width: 32
                                          * #c_type: unsigned_int
                                      * identifier: main::1::4::i#0
                                      * #SSA_symbol: 1
                                      * #full_identifier: main::1::4::i
                              1: constant
                                  * type: signedbv
                                      * width: 64
                                      * #c_type: signed_long_int
                                  * value: 0000000000000000000000000000000000000000000000000000000000000110
                          1: not
                              * type: bool
                              0: >=
                                  * type: bool
                                  * #source_location: 
                                    * file: main.c
                                    * line: 12
                                    * function: main
                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                  0: symbol
                                      * type: signedbv
                                          * width: 32
                                          * #c_type: signed_int
                                      * identifier: main::1::a[6]#1
                                      * #SSA_symbol: 1
                                      * #full_identifier: main::1::a[6]
                                  1: constant
                                      * type: signedbv
                                          * width: 32
                                          * #c_type: signed_int
                                      * value: 00000000000000000000000000001011
                          2: if
                              * type: bool
                              0: =
                                  * type: bool
                                  0: typecast
                                      * type: signedbv
                                          * width: 64
                                          * #c_type: signed_long_int
                                      0: symbol
                                          * type: unsignedbv
                                              * width: 32
                                              * #c_type: unsigned_int
                                          * identifier: main::1::4::i#0
                                          * #SSA_symbol: 1
                                          * #full_identifier: main::1::4::i
                                  1: constant
                                      * type: signedbv
                                          * width: 64
                                          * #c_type: signed_long_int
                                      * value: 0000000000000000000000000000000000000000000000000000000000000101
                              1: not
                                  * type: bool
                                  0: >=
                                      * type: bool
                                      * #source_location: 
                                        * file: main.c
                                        * line: 12
                                        * function: main
                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                      0: symbol
                                          * type: signedbv
                                              * width: 32
                                              * #c_type: signed_int
                                          * identifier: main::1::a[5]#1
                                          * #SSA_symbol: 1
                                          * #full_identifier: main::1::a[5]
                                      1: constant
                                          * type: signedbv
                                              * width: 32
                                              * #c_type: signed_int
                                          * value: 00000000000000000000000000001011
                              2: if
                                  * type: bool
                                  0: =
                                      * type: bool
                                      0: typecast
                                          * type: signedbv
                                              * width: 64
                                              * #c_type: signed_long_int
                                          0: symbol
                                              * type: unsignedbv
                                                  * width: 32
                                                  * #c_type: unsigned_int
                                              * identifier: main::1::4::i#0
                                              * #SSA_symbol: 1
                                              * #full_identifier: main::1::4::i
                                      1: constant
                                          * type: signedbv
                                              * width: 64
                                              * #c_type: signed_long_int
                                          * value: 0000000000000000000000000000000000000000000000000000000000000100
                                  1: not
                                      * type: bool
                                      0: >=
                                          * type: bool
                                          * #source_location: 
                                            * file: main.c
                                            * line: 12
                                            * function: main
                                            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                          0: symbol
                                              * type: signedbv
                                                  * width: 32
                                                  * #c_type: signed_int
                                              * identifier: main::1::a[4]#1
                                              * #SSA_symbol: 1
                                              * #full_identifier: main::1::a[4]
                                          1: constant
                                              * type: signedbv
                                                  * width: 32
                                                  * #c_type: signed_int
                                              * value: 00000000000000000000000000001011
                                  2: if
                                      * type: bool
                                      0: =
                                          * type: bool
                                          0: typecast
                                              * type: signedbv
                                                  * width: 64
                                                  * #c_type: signed_long_int
                                              0: symbol
                                                  * type: unsignedbv
                                                      * width: 32
                                                      * #c_type: unsigned_int
                                                  * identifier: main::1::4::i#0
                                                  * #SSA_symbol: 1
                                                  * #full_identifier: main::1::4::i
                                          1: constant
                                              * type: signedbv
                                                  * width: 64
                                                  * #c_type: signed_long_int
                                              * value: 0000000000000000000000000000000000000000000000000000000000000011
                                      1: not
                                          * type: bool
                                          0: >=
                                              * type: bool
                                              * #source_location: 
                                                * file: main.c
                                                * line: 12
                                                * function: main
                                                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                              0: symbol
                                                  * type: signedbv
                                                      * width: 32
                                                      * #c_type: signed_int
                                                  * identifier: main::1::a[3]#1
                                                  * #SSA_symbol: 1
                                                  * #full_identifier: main::1::a[3]
                                              1: constant
                                                  * type: signedbv
                                                      * width: 32
                                                      * #c_type: signed_int
                                                  * value: 00000000000000000000000000001011
                                      2: if
                                          * type: bool
                                          0: =
                                              * type: bool
                                              0: typecast
                                                  * type: signedbv
                                                      * width: 64
                                                      * #c_type: signed_long_int
                                                  0: symbol
                                                      * type: unsignedbv
                                                          * width: 32
                                                          * #c_type: unsigned_int
                                                      * identifier: main::1::4::i#0
                                                      * #SSA_symbol: 1
                                                      * #full_identifier: main::1::4::i
                                              1: constant
                                                  * type: signedbv
                                                      * width: 64
                                                      * #c_type: signed_long_int
                                                  * value: 0000000000000000000000000000000000000000000000000000000000000010
                                          1: not
                                              * type: bool
                                              0: >=
                                                  * type: bool
                                                  * #source_location: 
                                                    * file: main.c
                                                    * line: 12
                                                    * function: main
                                                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                  0: symbol
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * identifier: main::1::a[2]#1
                                                      * #SSA_symbol: 1
                                                      * #full_identifier: main::1::a[2]
                                                  1: constant
                                                      * type: signedbv
                                                          * width: 32
                                                          * #c_type: signed_int
                                                      * value: 00000000000000000000000000001011
                                          2: if
                                              * type: bool
                                              0: =
                                                  * type: bool
                                                  0: typecast
                                                      * type: signedbv
                                                          * width: 64
                                                          * #c_type: signed_long_int
                                                      0: symbol
                                                          * type: unsignedbv
                                                              * width: 32
                                                              * #c_type: unsigned_int
                                                          * identifier: main::1::4::i#0
                                                          * #SSA_symbol: 1
                                                          * #full_identifier: main::1::4::i
                                                  1: constant
                                                      * type: signedbv
                                                          * width: 64
                                                          * #c_type: signed_long_int
                                                      * value: 0000000000000000000000000000000000000000000000000000000000000001
                                              1: not
                                                  * type: bool
                                                  0: >=
                                                      * type: bool
                                                      * #source_location: 
                                                        * file: main.c
                                                        * line: 12
                                                        * function: main
                                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                      0: symbol
                                                          * type: signedbv
                                                              * width: 32
                                                              * #c_type: signed_int
                                                          * identifier: main::1::a[1]#1
                                                          * #SSA_symbol: 1
                                                          * #full_identifier: main::1::a[1]
                                                      1: constant
                                                          * type: signedbv
                                                              * width: 32
                                                              * #c_type: signed_int
                                                          * value: 00000000000000000000000000001011
                                              2: not
                                                  * type: bool
                                                  0: >=
                                                      * type: bool
                                                      * #source_location: 
                                                        * file: main.c
                                                        * line: 12
                                                        * function: main
                                                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-initialisation2
                                                      0: symbol
                                                          * type: signedbv
                                                              * width: 32
                                                              * #c_type: signed_int
                                                          * identifier: main::1::a[0]#1
                                                          * #SSA_symbol: 1
                                                          * #full_identifier: main::1::a[0]
                                                      1: constant
                                                          * type: signedbv
                                                              * width: 32
                                                              * #c_type: signed_int
                                                          * value: 00000000000000000000000000001011
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12711 variables, 62621 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12710 variables, 39711 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12710 variables, 62621 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
18841 variables, 95229 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12778 variables, 62983 clauses
SAT checker: instance is UNSATISFIABLE
Number of visited locations: 32 (out of 32)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 5 VCC(s), 5 remaining after simplification
Runtime total: 0.533117s
Runtime decision procedure: 0.49472s

** Results:
[main.assertion.1] forall a[]: FAILURE
[main.assertion.2] assertion a[(signed long int)9] > a[(signed long int)1]: SUCCESS
[main.assertion.3] assertion a[(signed long int)2] > a[(signed long int)3]: FAILURE
[main.assertion.4] forall c[]: SUCCESS
[main.assertion.5] assertion c[(signed long int)3] >= c[(signed long int)1]: SUCCESS

** 2 of 5 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\[main.assertion.1\] forall a\[\]: SUCCESS$ [FAILED]
^\*\* 1 of 5 failed [FAILED]


Failed test: Quantifiers-invalid-var-range
Parsing main.c
Converting
Type-checking main
file main.c line 7 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
warning: ignoring exists
  * type: bool
  * #source_location: 
    * file: main.c
    * line: 5
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
  0: symbol
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * identifier: main::1::1::1::j#0
      * #SSA_symbol: 1
      * #full_identifier: main::1::1::1::j
  1: or
      * type: bool
      * #source_location: 
        * file: main.c
        * line: 5
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
      0: >=
          * type: bool
          * #source_location: 
            * file: main.c
            * line: 5
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
          0: symbol
              * type: signedbv
                  * width: 32
                  * #c_type: signed_int
              * identifier: main::1::1::1::j#0
              * #SSA_symbol: 1
              * #full_identifier: main::1::1::1::j
          1: constant
              * type: signedbv
                  * width: 32
                  * #c_type: signed_int
              * value: 00000000000000000000000000000011
              * #source_location: 
                * file: main.c
                * line: 5
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
              * #base: 10
      1: if
          * type: bool
          0: =
              * type: bool
              0: typecast
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  0: symbol
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * identifier: main::1::1::1::j#0
                      * #SSA_symbol: 1
                      * #full_identifier: main::1::1::1::j
              1: constant
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  * value: 0000000000000000000000000000000000000000000000000000000000000010
          1: =
              * type: bool
              * #source_location: 
                * file: main.c
                * line: 5
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
              0: symbol
                  * type: signedbv
                      * width: 32
                      * #c_type: signed_int
                  * identifier: main::1::a[*][2]#0
                  * #SSA_symbol: 1
                  * #full_identifier: main::1::a[*][2]
              1: constant
                  * type: signedbv
                      * width: 32
                      * #c_type: signed_int
                  * value: 00000000000000000000000000001010
                  * #source_location: 
                    * file: main.c
                    * line: 5
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
                  * #base: 10
          2: if
              * type: bool
              0: =
                  * type: bool
                  0: typecast
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      0: symbol
                          * type: signedbv
                              * width: 32
                              * #c_type: signed_int
                          * identifier: main::1::1::1::j#0
                          * #SSA_symbol: 1
                          * #full_identifier: main::1::1::1::j
                  1: constant
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      * value: 0000000000000000000000000000000000000000000000000000000000000001
              1: =
                  * type: bool
                  * #source_location: 
                    * file: main.c
                    * line: 5
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
                  0: symbol
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * identifier: main::1::a[*][1]#0
                      * #SSA_symbol: 1
                      * #full_identifier: main::1::a[*][1]
                  1: constant
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * value: 00000000000000000000000000001010
                      * #source_location: 
                        * file: main.c
                        * line: 5
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
                      * #base: 10
              2: =
                  * type: bool
                  * #source_location: 
                    * file: main.c
                    * line: 5
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
                  0: symbol
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * identifier: main::1::a[*][0]#0
                      * #SSA_symbol: 1
                      * #full_identifier: main::1::a[*][0]
                  1: constant
                      * type: signedbv
                          * width: 32
                          * #c_type: signed_int
                      * value: 00000000000000000000000000001010
                      * #source_location: 
                        * file: main.c
                        * line: 5
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
                      * #base: 10
      2: not
          * type: bool
          0: >=
              * type: bool
              * #source_location: 
                * file: main.c
                * line: 5
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers-invalid-var-range
              0: symbol
                  * type: signedbv
                      * width: 32
                      * #c_type: signed_int
                  * identifier: main::1::1::1::j#0
                  * #SSA_symbol: 1
                  * #full_identifier: main::1::1::1::j
              1: constant
                  * type: signedbv
                      * width: 32
                      * #c_type: signed_int
                  * value: 00000000000000000000000000000100
Solving with MiniSAT 2.2.1 with simplifier
422 variables, 246 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 36 (out of 36)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 3 VCC(s), 1 remaining after simplification
Runtime total: 0.0029092s
Runtime decision procedure: 0.00185759s

** Results:
[main.assertion.1] assertion tmp_if_expr$0: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\* 0 of 1 failed [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^EXIT=0$ [FAILED]


Failed test: Quantifiers-not-exists
Parsing main.c
Converting
Type-checking main
file main.c line 18 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1300 variables, 2008 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1549 variables, 3051 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1514 variables, 2921 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1479 variables, 2725 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1440 variables, 2532 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1371 variables, 2272 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 126 (out of 128)
Number of dropped states: 0
Number of paths: 320
Number of infeasible paths: 0
Generated 428 VCC(s), 6 remaining after simplification
Runtime total: 0.0960297s
Runtime decision procedure: 0.0343147s

** Results:
[main.assertion.1] assertion a[(signed long int)0][(signed long int)0] > 10: FAILURE
[main.assertion.2] assertion tmp_if_expr$1: FAILURE
[main.assertion.3] assertion tmp_if_expr$4: FAILURE
[main.assertion.4] assertion tmp_if_expr$7: FAILURE
[main.assertion.5] assertion tmp_if_expr$10: FAILURE
[main.assertion.6] assertion tmp_if_expr$13: FAILURE

** 6 of 6 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\[main.assertion.1\] assertion a\[.*\]\[.*\] > 10: SUCCESS$ [FAILED]
^\[main.assertion.2\] assertion tmp_if_expr\$\d+: SUCCESS$ [FAILED]
^\[main.assertion.3\] assertion tmp_if_expr\$\d+: SUCCESS$ [FAILED]
^\[main.assertion.4\] assertion tmp_if_expr\$\d+: SUCCESS$ [FAILED]
^\[main.assertion.5\] assertion tmp_if_expr\$\d+: SUCCESS$ [FAILED]
^\[main.assertion.6\] assertion tmp_if_expr\$\d+: SUCCESS$ [FAILED]
^\*\* 0 of 6 failed [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^EXIT=0$ [FAILED]


Failed test: Quantifiers1
Parsing main.c
Converting
Type-checking main
file main.c line 6 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
9 variables, 0 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
9 variables, 0 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
warning: ignoring forall
  * type: bool
  * #source_location: 
    * file: main.c
    * line: 18
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers1
  0: symbol
      * type: unsignedbv
          * width: 32
          * #c_type: unsigned_int
      * identifier: main::1::4::i#0
      * #SSA_symbol: 1
      * #full_identifier: main::1::4::i
  1: or
      * type: bool
      * #source_location: 
        * file: main.c
        * line: 18
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers1
      0: =
          * type: bool
          * #source_location: 
            * file: main.c
            * line: 18
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers1
          0: typecast
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              0: symbol
                  * type: signedbv
                      * width: 8
                      * #c_type: char
                  * identifier: main::1::c[*]#0
                  * #SSA_symbol: 1
                  * #full_identifier: main::1::c[*]
          1: symbol
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              * identifier: main::1::4::i#0
              * #SSA_symbol: 1
              * #full_identifier: main::1::4::i
      1: >=
          * type: bool
          * #source_location: 
            * file: main.c
            * line: 18
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/Quantifiers1
          0: symbol
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              * identifier: main::1::4::i#0
              * #SSA_symbol: 1
              * #full_identifier: main::1::4::i
          1: constant
              * type: unsignedbv
                  * width: 32
                  * #c_type: unsigned_int
              * value: 00000000000000000000000000001010
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
137 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 40 (out of 40)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 3 VCC(s), 3 remaining after simplification
Runtime total: 0.00368158s
Runtime decision procedure: 0.00149166s

** Results:
[main.assertion.1] assertion forall { signed int i; i >= 0 && i < 10 ==> zero_array[(signed long int)i] == 0 }: SUCCESS
[main.assertion.2] assertion forall { signed int i; i >= 0 && i < 10 ==> zero_array[(signed long int)i] == 0 }: SUCCESS
[main.assertion.3] assertion forall { unsigned int i; i > (unsigned int)9 || (unsigned int)c[(signed long int)i] == i }: FAILURE

** 1 of 3 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^warning: ignoring [FAILED]


Failed test: Recursion6
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property recursion.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
136 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property recursion.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
136 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property recursion.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
136 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 39 (out of 39)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 4 VCC(s), 3 remaining after simplification
Runtime total: 0.00213273s
Runtime decision procedure: 0.00137631s

** Results:
[recursion.assertion.1] assertion other_local==30: FAILURE
[recursion.assertion.2] assertion !rec: FAILURE
[recursion.assertion.3] assertion some_local==1: FAILURE
[recursion.assertion.4] assertion other_local==20: SUCCESS

** 3 of 4 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: Undefined_Function1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
73 variables, 44 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 19 (out of 26)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.000771705s
Runtime decision procedure: 0.000434014s

** Results:
[main.assertion.1] assertion i==1: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\*\*\* WARNING: no body for function f$ [FAILED]


Failed test: Undefined_Function2
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
169 variables, 172 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 21 (out of 29)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00112778s
Runtime decision procedure: 0.000687981s

** Results:
[main.assertion.1] assertion v1==v2: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\*\*\* WARNING: no body for function asd$ [FAILED]


Failed test: address_space_size_limit1
Parsing test.c
Converting
Type-checking test
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 58 (out of 58)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 300 VCC(s), 0 remaining after simplification
Runtime total: 0.461653s
Runtime decision procedure: 0s

** Results:
[main.assertion.1] assertion c!=(char*)0: SUCCESS

** 0 of 1 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
too many addressed objects [FAILED]
^EXIT=6$ [FAILED]


Failed test: argv1
Parsing main.c
Converting
Type-checking main
file main.c line 7 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.pointer_dereference.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
11376 variables, 23558 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
11285 variables, 260 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.pointer_dereference.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12056 variables, 26010 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
libc++abi.dylib: terminating with uncaught exception of type std::__nested<bitvector_conversion_exceptiont>: Can't convert byte_extraction
EXIT=134
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: big-endian-array1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
737 variables, 917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 2493 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1608 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1658 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1668 variables, 1220 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Number of visited locations: 80 (out of 80)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 6 VCC(s), 6 remaining after simplification
Runtime total: 0.0208283s
Runtime decision procedure: 0.0172318s

** Results:
[main.assertion.1] array[0] matches: SUCCESS
[main.assertion.2] p[0] matches: FAILURE
[main.assertion.3] p[1] matches: SUCCESS
[main.assertion.4] p[2] matches: SUCCESS
[main.assertion.5] p[3] matches: SUCCESS
[main.assertion.6] p[0,1] matches: SUCCESS

** 1 of 6 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update2
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 8614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 11983 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.10
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.11
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.12
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.13
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.14
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.15
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.16
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13479 variables, 12135 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 57 (out of 84)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 16 VCC(s), 16 remaining after simplification
Runtime total: 0.363819s
Runtime decision procedure: 0.343053s

** Results:
[main.assertion.1] assertion alias2[0]==0x08: FAILURE
[main.assertion.2] assertion alias2[1]==0x07: FAILURE
[main.assertion.3] assertion alias2[2]==0x06: FAILURE
[main.assertion.4] assertion alias2[3]==0x05: FAILURE
[main.assertion.5] assertion alias2[4]==0x04: FAILURE
[main.assertion.6] assertion alias2[5]==0xed: SUCCESS
[main.assertion.7] assertion alias2[6]==0x02: FAILURE
[main.assertion.8] assertion alias2[7]==0x01: FAILURE
[main.assertion.9] assertion alias2[8]==0x18: FAILURE
[main.assertion.10] assertion alias2[9]==0x17: FAILURE
[main.assertion.11] assertion alias2[10]==0x16: FAILURE
[main.assertion.12] assertion alias2[11]==0x15: FAILURE
[main.assertion.13] assertion alias2[12]==0x14: FAILURE
[main.assertion.14] assertion alias2[13]==0x13: FAILURE
[main.assertion.15] assertion alias2[14]==0x12: FAILURE
[main.assertion.16] assertion alias2[15]==0x11: FAILURE

** 15 of 16 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update3
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6132 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6132 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6181 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6181 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6230 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6230 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6279 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 6279 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 8774 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.10
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12364 variables, 8774 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 54 (out of 81)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 10 VCC(s), 10 remaining after simplification
Runtime total: 0.163786s
Runtime decision procedure: 0.150786s

** Results:
[main.assertion.1] assertion alias2[0]==0xf8: SUCCESS
[main.assertion.2] assertion alias2[1]==0xf7: SUCCESS
[main.assertion.3] assertion alias2[2]==0xf6: SUCCESS
[main.assertion.4] assertion alias2[3]==0xf5: SUCCESS
[main.assertion.5] assertion alias2[4]==0xf4: SUCCESS
[main.assertion.6] assertion alias2[5]==0xf3: SUCCESS
[main.assertion.7] assertion alias2[6]==0xf2: SUCCESS
[main.assertion.8] assertion alias2[7]==0xf1: SUCCESS
[main.assertion.9] assertion alias2[8]==0x0a: FAILURE
[main.assertion.10] assertion alias2[9]==0x09: FAILURE

** 2 of 10 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update4
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12581 variables, 9289 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 59 (out of 86)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 10 VCC(s), 8 remaining after simplification
Runtime total: 0.174168s
Runtime decision procedure: 0.162286s

** Results:
[main.assertion.1] assertion alias2[0]==0x01: SUCCESS
[main.assertion.2] assertion alias2[1]==0xf8: FAILURE
[main.assertion.3] assertion alias2[2]==0xf7: FAILURE
[main.assertion.4] assertion alias2[3]==0xf6: FAILURE
[main.assertion.5] assertion alias2[4]==0xf5: FAILURE
[main.assertion.6] assertion alias2[5]==0xf4: FAILURE
[main.assertion.7] assertion alias2[6]==0xf3: FAILURE
[main.assertion.8] assertion alias2[7]==0xf2: FAILURE
[main.assertion.9] assertion alias2[8]==0xf1: FAILURE
[main.assertion.10] assertion alias2[9]==0x0a: SUCCESS

** 8 of 10 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update5
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 10074 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7811 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 7827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.10
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
12928 variables, 10298 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 54 (out of 81)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 10 VCC(s), 10 remaining after simplification
Runtime total: 0.176683s
Runtime decision procedure: 0.162737s

** Results:
[main.assertion.1] assertion alias2[0]==0x02: FAILURE
[main.assertion.2] assertion alias2[1]==0xf8: SUCCESS
[main.assertion.3] assertion alias2[2]==0xf7: SUCCESS
[main.assertion.4] assertion alias2[3]==0xf6: SUCCESS
[main.assertion.5] assertion alias2[4]==0xf5: SUCCESS
[main.assertion.6] assertion alias2[5]==0xf4: SUCCESS
[main.assertion.7] assertion alias2[6]==0xf3: SUCCESS
[main.assertion.8] assertion alias2[7]==0xf2: SUCCESS
[main.assertion.9] assertion alias2[8]==0xf1: SUCCESS
[main.assertion.10] assertion alias2[9]==0x09: FAILURE

** 2 of 10 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update6
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13276 variables, 11124 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 8550 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.10
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 8550 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.11
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.12
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.13
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.14
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.15
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.16
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11783 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 57 (out of 84)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 16 VCC(s), 16 remaining after simplification
Runtime total: 0.363805s
Runtime decision procedure: 0.3441s

** Results:
[main.assertion.1] assertion alias2[0]==0x08: FAILURE
[main.assertion.2] assertion alias2[1]==0x07: FAILURE
[main.assertion.3] assertion alias2[2]==0x06: FAILURE
[main.assertion.4] assertion alias2[3]==0x05: FAILURE
[main.assertion.5] assertion alias2[4]==0x04: FAILURE
[main.assertion.6] assertion alias2[5]==0x03: FAILURE
[main.assertion.7] assertion alias2[6]==0x02: FAILURE
[main.assertion.8] assertion alias2[7]==0x01: FAILURE
[main.assertion.9] assertion alias2[8]==0xcb: SUCCESS
[main.assertion.10] assertion alias2[9]==0xed: SUCCESS
[main.assertion.11] assertion alias2[10]==0x16: FAILURE
[main.assertion.12] assertion alias2[11]==0x15: FAILURE
[main.assertion.13] assertion alias2[12]==0x14: FAILURE
[main.assertion.14] assertion alias2[13]==0x13: FAILURE
[main.assertion.15] assertion alias2[14]==0x12: FAILURE
[main.assertion.16] assertion alias2[15]==0x11: FAILURE

** 14 of 16 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: byte_update7
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11935 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.8
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 8566 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 8566 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.10
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.11
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.12
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.13
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.14
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.15
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.16
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
13471 variables, 11991 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 57 (out of 84)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 16 VCC(s), 16 remaining after simplification
Runtime total: 0.378875s
Runtime decision procedure: 0.356825s

** Results:
[main.assertion.1] assertion alias2[0]==0x08: FAILURE
[main.assertion.2] assertion alias2[1]==0x07: FAILURE
[main.assertion.3] assertion alias2[2]==0x06: FAILURE
[main.assertion.4] assertion alias2[3]==0x05: FAILURE
[main.assertion.5] assertion alias2[4]==0x04: FAILURE
[main.assertion.6] assertion alias2[5]==0x03: FAILURE
[main.assertion.7] assertion alias2[6]==0x02: FAILURE
[main.assertion.8] assertion alias2[7]==0xcb: SUCCESS
[main.assertion.9] assertion alias2[8]==0xed: SUCCESS
[main.assertion.10] assertion alias2[9]==0x17: FAILURE
[main.assertion.11] assertion alias2[10]==0x16: FAILURE
[main.assertion.12] assertion alias2[11]==0x15: FAILURE
[main.assertion.13] assertion alias2[12]==0x14: FAILURE
[main.assertion.14] assertion alias2[13]==0x13: FAILURE
[main.assertion.15] assertion alias2[14]==0x12: FAILURE
[main.assertion.16] assertion alias2[15]==0x11: FAILURE

** 14 of 16 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: coverage_report1
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --symex-coverage-report
EXIT=64
SIGNAL=0


Failed test.desc lines:
<line branch="false" hits="1" number="12"/> [FAILED]
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: fgets1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property fgets.pointer_dereference.16
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
810 variables, 1201 clauses
SAT checker: instance is SATISFIABLE
unexpected OTHER statement: array_replace
Number of visited locations: 92 (out of 228)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 24 VCC(s), 1 remaining after simplification
Runtime total: 0.00445064s
Runtime decision procedure: 0.00233425s

** Results:
[main.pointer_dereference.1] dereference failure: pointer NULL
[main.pointer_dereference.2] dereference failure: pointer invalid
[main.pointer_dereference.3] dereference failure: deallocated dynamic object
[main.pointer_dereference.4] dereference failure: dead object
[main.pointer_dereference.5] dereference failure: pointer outside dynamic object bounds
[main.pointer_dereference.6] dereference failure: pointer outside object bounds
[main.pointer_dereference.7] dereference failure: invalid integer address
[main.assertion.1] assertion buffer[1]==p[1]: SUCCESS
[main.assertion.2] assertion buffer[2]=='\0': SUCCESS
[main.assertion.3] assertion p[1]=='b': SUCCESS
[fgets.pointer_dereference.1] dereference failure: pointer NULL
[fgets.pointer_dereference.2] dereference failure: pointer invalid
[fgets.pointer_dereference.3] dereference failure: deallocated dynamic object
[fgets.pointer_dereference.4] dereference failure: dead object
[fgets.pointer_dereference.5] dereference failure: pointer outside dynamic object bounds
[fgets.pointer_dereference.6] dereference failure: pointer outside object bounds
[fgets.pointer_dereference.7] dereference failure: invalid integer address
[fgets.pointer_dereference.8] dereference failure: pointer NULL
[fgets.pointer_dereference.9] dereference failure: pointer invalid
[fgets.pointer_dereference.10] dereference failure: deallocated dynamic object
[fgets.pointer_dereference.11] dereference failure: dead object
[fgets.pointer_dereference.12] dereference failure: pointer outside dynamic object bounds
[fgets.pointer_dereference.13] dereference failure: pointer outside object bounds
[fgets.pointer_dereference.14] dereference failure: invalid integer address
[fgets.pointer_dereference.15] dereference failure: pointer outside dynamic object bounds
[fgets.pointer_dereference.16] dereference failure: pointer outside object bounds
[fgets.pointer_dereference.17] dereference failure: invalid integer address
[fgets.pointer_dereference.18] dereference failure: pointer outside dynamic object bounds
[fgets.pointer_dereference.19] dereference failure: pointer outside object bounds
[fgets.pointer_dereference.20] dereference failure: invalid integer address
[_fdopen.pointer_dereference.1] : SUCCESS
[_fdopen.pointer_dereference.2] : SUCCESS
[_fdopen.pointer_dereference.3] : SUCCESS
[_fdopen.pointer_dereference.4] : SUCCESS
[_fdopen.pointer_dereference.5] : SUCCESS
[_fdopen.pointer_dereference.6] : SUCCESS
[_fdopen.pointer_dereference.7] : SUCCESS

** 1 of 37 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
\[main.assertion.3\] assertion p\[1\]=='b': FAILURE [FAILED]
\*\* 2 of \d+ failed [FAILED]


Failed test: full_slice1
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --full-slice
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED [FAILED]


Failed test: full_slice2
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --full-slice
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED [FAILED]


Failed test: gcc_local_label1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 15 (out of 26)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.000278263s
Runtime decision procedure: 0s

** Results:
[other_f.assertion.1] assertion 0: SUCCESS

** 0 of 1 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: goto4
Parsing main.c
Converting
Type-checking main
file main.c line 5 function f: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 17 (out of 31)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.000423382s
Runtime decision procedure: 0s

** Results:
[f.assertion.1] assertion g == 0: SUCCESS

** 0 of 1 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^\[.*] unwinding assertion loop 0: FAILURE$ [FAILED]


Failed test: graphml_witness1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 20 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 30 (out of 43)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00106839s
Runtime decision procedure: 0.0005031s

** Results:
[main.assertion.1] : FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> [FAILED]
  <key attr.name="invariant" attr.type="string" for="node" id="invariant"/> [FAILED]
  <key attr.name="invariant.scope" attr.type="string" for="node" id="invariant.scope"/> [FAILED]
  <key attr.name="nodeType" attr.type="string" for="node" id="nodetype"> [FAILED]
    <default>path</default> [FAILED]
  </key> [FAILED]
  <key attr.name="isFrontierNode" attr.type="boolean" for="node" id="frontier"> [FAILED]
    <default>false</default> [FAILED]
  </key> [FAILED]
  <key attr.name="isViolationNode" attr.type="boolean" for="node" id="violation"> [FAILED]
    <default>false</default> [FAILED]
  </key> [FAILED]
  <key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry"> [FAILED]
    <default>false</default> [FAILED]
  </key> [FAILED]
  <key attr.name="isSinkNode" attr.type="boolean" for="node" id="sink"> [FAILED]
    <default>false</default> [FAILED]
  </key> [FAILED]
  <key attr.name="enterLoopHead" attr.type="boolean" for="edge" id="enterLoopHead"> [FAILED]
    <default>false</default> [FAILED]
  </key> [FAILED]
  <key attr.name="threadNumber" attr.type="int" for="node" id="thread"> [FAILED]
    <default>0</default> [FAILED]
  </key> [FAILED]
  <key attr.name="sourcecodeLanguage" attr.type="string" for="graph" id="sourcecodelang"/> [FAILED]
  <key attr.name="programFile" attr.type="string" for="graph" id="programfile"/> [FAILED]
  <key attr.name="programHash" attr.type="string" for="graph" id="programhash"/> [FAILED]
  <key attr.name="specification" attr.type="string" for="graph" id="specification"/> [FAILED]
  <key attr.name="architecture" attr.type="string" for="graph" id="architecture"/> [FAILED]
  <key attr.name="producer" attr.type="string" for="graph" id="producer"/> [FAILED]
  <key attr.name="sourcecode" attr.type="string" for="edge" id="sourcecode"/> [FAILED]
  <key attr.name="startline" attr.type="int" for="edge" id="startline"/> [FAILED]
  <key attr.name="control" attr.type="string" for="edge" id="control"/> [FAILED]
  <key attr.name="assumption" attr.type="string" for="edge" id="assumption"/> [FAILED]
  <key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"/> [FAILED]
  <key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"/> [FAILED]
  <key attr.name="enterFunction" attr.type="string" for="edge" id="enterFunction"/> [FAILED]
  <key attr.name="returnFromFunction" attr.type="string" for="edge" id="returnFrom"/> [FAILED]
  <key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"/> [FAILED]
  <graph edgedefault="directed"> [FAILED]
    <data key="sourcecodelang">C</data> [FAILED]
    <node id="sink"/> [FAILED]
    <node id="[0-9\.]*"> [FAILED]
      <data key="entry">true</data> [FAILED]
    </node> [FAILED]
    <edge source="[0-9\.]*" target="[0-9\.]*"> [FAILED]
      <data key="originfile">main.c</data> [FAILED]
      <data key="startline">21</data> [FAILED]
    </edge> [FAILED]
    <node id="[0-9\.]*"/> [FAILED]
    <edge source="[0-9\.]*" target="[0-9\.]*"> [FAILED]
      <data key="originfile">main.c</data> [FAILED]
      <data key="startline">29</data> [FAILED]
      <data key="assumption.scope">main</data> [FAILED]
    </edge> [FAILED]
    <node id="[0-9\.]*"/> [FAILED]
    <edge source="[0-9\.]*" target="[0-9\.]*"> [FAILED]
      <data key="originfile">main.c</data> [FAILED]
      <data key="startline">15</data> [FAILED]
      <data key="assumption.scope">remove_one</data> [FAILED]
    </edge> [FAILED]
    <node id="[0-9\.]*"> [FAILED]
      <data key="violation">true</data> [FAILED]
    </node> [FAILED]
    <edge source="[0-9\.]*" target="sink"> [FAILED]
      <data key="originfile">main.c</data> [FAILED]
      <data key="startline">31</data> [FAILED]
    </edge> [FAILED]
  </graph> [FAILED]
</graphml> [FAILED]


Failed test: havoc_object1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 54 (out of 54)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 8 VCC(s), 0 remaining after simplification
Runtime total: 0.00193592s
Runtime decision procedure: 0s

** Results:
[main.assertion.1] i==0: SUCCESS
[main.assertion.2] array[3]: SUCCESS
[main.assertion.3] struct i: SUCCESS
[main.assertion.4] struct j: SUCCESS
[main.assertion.5] i==20 (A): SUCCESS
[main.assertion.6] some_struct.i==30 (A): SUCCESS
[main.assertion.7] i==20 (B): SUCCESS
[main.assertion.8] some_struct.i==30 (B): SUCCESS

** 0 of 8 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]
^\*\* 6 of 8 failed.*$ [FAILED]


Failed test: hex_trace
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --trace-hex
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
a=0 \s*\(0x0\) [FAILED]
b=0ul? \s*\(0x0\) [FAILED]
a=-100 \s*\(0xFFFFFF9C\) [FAILED]
a=2147483647 \s*\(0x7FFFFFFF\) [FAILED]
b=4294967294ul? \s*\(0xFFFFFFFE\) [FAILED]
a=-2147483647 \s*\(0x80000001\) [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: json1
[
  {
    "program": "Symex 5.9 (cbmc-5.9-517-g80331d8a5)"
  },
  {
    "messageText": "Parsing main.c",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Converting",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Type-checking main",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "function `assert' is not declared",
    "messageType": "WARNING",
    "sourceLocation": {
      "file": "main.c",
      "function": "main",
      "line": "4",
      "workingDirectory": "/Users/kroening/progr/cbmc-git/regression/cbmc/json1"
    }
  },
  {
    "messageText": "Generating GOTO Program",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Generic Property Instrumentation",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Removal of function pointers and virtual functions",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Starting symbolic simulation",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Checking property main.assertion.1",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Post-processing",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Solving with MiniSAT 2.2.1 with simplifier",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "41 variables, 44 clauses",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "SAT checker: instance is SATISFIABLE",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of visited locations: 16 (out of 23)",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of dropped states: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of paths: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of infeasible paths: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Generated 1 VCC(s), 1 remaining after simplification",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Runtime total: 0.00102806s\nRuntime decision procedure: 0.000500229s",
    "messageType": "STATUS-MESSAGE"
  }--- begin invariant violation report ---
Invariant check failed
File symex_parse_options.cpp function show_trace line 542
Reason: Unreachable
Backtrace:
Backtraces not supported


--- end invariant violation report ---
EXIT=134
SIGNAL=0


Failed test.desc lines:
EXIT=10 [FAILED]
\[\n  \{\n    "program": "CBMC .*"\n  \},\n  \{\n    "messageText": "CBMC .*",\n    "messageType": "STATUS-MESSAGE"\n  \},\n  \{\n    "messageText": "Parsing main\.c",\n    "messageType": "STATUS-MESSAGE"\n  \}, [FAILED]
\]\n  \},\n  \{\n    "messageText": "VERIFICATION FAILED",\n    "messageType": "STATUS-MESSAGE"\n  \},\n  \{\n    "cProverStatus": "failure"\n  \}\n\] [FAILED]


Failed test: little-endian-array1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
737 variables, 917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 2493 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1608 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1588 variables, 1658 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1668 variables, 1220 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Number of visited locations: 80 (out of 80)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 6 VCC(s), 6 remaining after simplification
Runtime total: 0.0251784s
Runtime decision procedure: 0.020751s

** Results:
[main.assertion.1] array[0] matches: SUCCESS
[main.assertion.2] p[0] matches: FAILURE
[main.assertion.3] p[1] matches: SUCCESS
[main.assertion.4] p[2] matches: SUCCESS
[main.assertion.5] p[3] matches: SUCCESS
[main.assertion.6] p[0,1] matches: SUCCESS

** 1 of 6 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: memory_allocation1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
105 variables, 44 clauses
SAT checker: instance is SATISFIABLE
Checking property main.pointer_dereference.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
72 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property main.pointer_dereference.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
72 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
105 variables, 44 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 32 (out of 32)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 6 VCC(s), 4 remaining after simplification
Runtime total: 0.00300426s
Runtime decision procedure: 0.00180332s

** Results:
[main.pointer_dereference.1] dereference failure: invalid integer address
[main.pointer_dereference.2] dereference failure: invalid integer address
[main.assertion.1] assertion *p==42: FAILURE
[main.pointer_dereference.3] dereference failure: invalid integer address
[main.pointer_dereference.4] dereference failure: invalid integer address
[main.assertion.2] assertion *(p+1)==42: FAILURE

** 4 of 6 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\[main\.assertion\.1\] assertion \*p==42: SUCCESS$ [FAILED]
^\[main\.assertion\.2\] assertion \*\(p\+1\)==42: SUCCESS$ [FAILED]


Failed test: memset1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
array_set expects address
Number of visited locations: 24 (out of 80)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 0 remaining after simplification
Runtime total: 0.000533895s
Runtime decision procedure: 0s

** Results:
[main.precondition_instance.1] memset destination region writeable: SUCCESS
[main.assertion.1] assertion A[0]==0: SUCCESS
[main.assertion.2] assertion A[1]==0: SUCCESS
[main.assertion.3] assertion A[2]==0: SUCCESS
[main.assertion.4] assertion A[3]==0: SUCCESS
[main.assertion.5] assertion A[4]==0: SUCCESS
[main.precondition_instance.2] memset destination region writeable: SUCCESS
[main.assertion.6] assertion A[0]==0x01010101: SUCCESS
[main.assertion.7] assertion A[1]==0x01010111: SUCCESS
[main.assertion.8] assertion A[2]==0x01010101: SUCCESS
[main.assertion.9] assertion A[3]==42: SUCCESS
[main.assertion.10] assertion A[4]==0: SUCCESS
[main.precondition_instance.3] memset destination region writeable: SUCCESS
[main.assertion.11] assertion B[0]==0x02020202: SUCCESS
[main.assertion.12] assertion B[1]==0x02020202: SUCCESS

** 0 of 15 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]
^\[main.assertion.7\] assertion A\[1\]==0x01010111: FAILURE$ [FAILED]
\*\* 1 of [0-9]+ failed [FAILED]


Failed test: memset3
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.precondition_instance.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
268 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 40 (out of 62)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00247043s
Runtime decision procedure: 0.00132348s

** Results:
[main.precondition_instance.1] memset destination region writeable: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
\*\* 1 of [0-9]+ failed \(.*\) [FAILED]


Failed test: mm_io1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
161 variables, 20 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 37 (out of 49)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 2 VCC(s), 1 remaining after simplification
Runtime total: 0.00143594s
Runtime decision procedure: 0.00065581s

** Results:
[main.assertion.1] reading 0x11: FAILURE
[main.assertion.2] reading &some_var: SUCCESS
[__CPROVER_mm_io_w.assertion.1] correct value written: SUCCESS

** 1 of 3 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: no_nondet_static
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --nondet-static
EXIT=64
SIGNAL=0


Failed test.desc lines:
^VERIFICATION FAILED$ [FAILED]
^EXIT=10$ [FAILED]
assertion x == 0: FAILURE [FAILED]
assertion y == 23: FAILURE [FAILED]
assertion s1.x == 0: FAILURE [FAILED]
assertion s2.x == 23: FAILURE [FAILED]
assertion a\[0\].x == 23: FAILURE [FAILED]
assertion a\[0\].p == &x: FAILURE [FAILED]
assertion c\[2\].x == 23: FAILURE [FAILED]
assertion c\[2\].p == &z: FAILURE [FAILED]
assertion z == 23: SUCCESS [FAILED]
assertion s3.x == 23: SUCCESS [FAILED]
assertion t1.y == 0: SUCCESS [FAILED]
assertion t2.y == 23: SUCCESS [FAILED]
assertion t3.x == 23: SUCCESS [FAILED]
assertion t3.y == 23: SUCCESS [FAILED]
assertion u1.x == 0: SUCCESS [FAILED]
assertion u2.x == 23: SUCCESS [FAILED]
assertion u3.x == 23: SUCCESS [FAILED]
assertion p == 23: SUCCESS [FAILED]
assertion q == 23: SUCCESS [FAILED]
assertion t1.x == 0: SUCCESS [FAILED]
assertion t2.x == 23: SUCCESS [FAILED]
assertion b\[1\].x == 23: SUCCESS [FAILED]
assertion b\[1\].p == &y: SUCCESS [FAILED]
assertion d\[1\].y == &y: SUCCESS [FAILED]
assertion linked_list.datum == 5: SUCCESS [FAILED]
assertion linked_list.next->datum == 10: SUCCESS [FAILED]
assertion one_list.a == 5: SUCCESS [FAILED]
assertion array\[1\] == 6: SUCCESS [FAILED]


Failed test: null3
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 18
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/null3
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: b
      * #source_location: 
        * file: main.c
        * line: 18
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/null3
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-S
              * #source_location: 
                * file: main.c
                * line: 18
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/null3
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
513 variables, 936 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 21 (out of 34)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.00221307s
Runtime decision procedure: 0.00159563s

** Results:
[main.assertion.1] assertion s_ptr==&s: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^warning: ignoring [FAILED]


Failed test: offsetof1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.10
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 37
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: i
      * #source_location: 
        * file: main.c
        * line: 37
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-S
              * #source_location: 
                * file: main.c
                * line: 37
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.11
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 8
          * #c_type: char
  * #source_location: 
    * file: main.c
    * line: 38
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 8
          * #c_type: char
      * component_name: ch
      * #source_location: 
        * file: main.c
        * line: 38
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-S
              * #source_location: 
                * file: main.c
                * line: 38
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.12
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 39
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: j
      * #source_location: 
        * file: main.c
        * line: 39
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-S
              * #source_location: 
                * file: main.c
                * line: 39
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.13
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 40
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: x
      * #source_location: 
        * file: main.c
        * line: 40
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: member
          * type: symbol
              * identifier: tag-Ssub
              * #source_location: 
                * file: main.c
                * line: 9
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * component_name: sub
          * #source_location: 
            * file: main.c
            * line: 40
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * #lvalue: 1
          0: integer_dereference
              * type: symbol
                  * identifier: tag-S
                  * #source_location: 
                    * file: main.c
                    * line: 40
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              0: constant
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.14
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 41
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: y
      * #source_location: 
        * file: main.c
        * line: 41
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: member
          * type: symbol
              * identifier: tag-Ssub
              * #source_location: 
                * file: main.c
                * line: 9
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * component_name: sub
          * #source_location: 
            * file: main.c
            * line: 41
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * #lvalue: 1
          0: integer_dereference
              * type: symbol
                  * identifier: tag-S
                  * #source_location: 
                    * file: main.c
                    * line: 41
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              0: constant
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.15
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: array
          * size: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000001100100
          * #source_location: 
            * file: main.c
            * line: 12
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: symbol
              * identifier: tag-Ssub
              * #source_location: 
                * file: main.c
                * line: 9
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  * #source_location: 
    * file: main.c
    * line: 42
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: array
          * size: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000001100100
          * #source_location: 
            * file: main.c
            * line: 12
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: symbol
              * identifier: tag-Ssub
              * #source_location: 
                * file: main.c
                * line: 9
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * component_name: array
      * #source_location: 
        * file: main.c
        * line: 42
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: integer_dereference
          * type: symbol
              * identifier: tag-S
              * #source_location: 
                * file: main.c
                * line: 42
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          0: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.16
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: symbol
          * identifier: tag-Ssub
          * #source_location: 
            * file: main.c
            * line: 9
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  * #source_location: 
    * file: main.c
    * line: 43
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: index
      * type: symbol
          * identifier: tag-Ssub
          * #source_location: 
            * file: main.c
            * line: 9
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #source_location: 
        * file: main.c
        * line: 43
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: member
          * type: array
              * size: constant
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  * value: 0000000000000000000000000000000000000000000000000000000001100100
              * #source_location: 
                * file: main.c
                * line: 12
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              0: symbol
                  * identifier: tag-Ssub
                  * #source_location: 
                    * file: main.c
                    * line: 9
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * component_name: array
          * #source_location: 
            * file: main.c
            * line: 43
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * #lvalue: 1
          0: integer_dereference
              * type: symbol
                  * identifier: tag-S
                  * #source_location: 
                    * file: main.c
                    * line: 43
                    * function: main
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              0: constant
                  * type: signedbv
                      * width: 64
                      * #c_type: signed_long_int
                  * value: 0000000000000000000000000000000000000000000000000000000000000000
      1: constant
          * type: signedbv
              * width: 64
              * #c_type: signed_long_int
          * value: 0000000000000000000000000000000000000000000000000000000000000000
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.17
warning: ignoring address_of
  * type: pointer
      * width: 64
      0: signedbv
          * width: 32
          * #c_type: signed_int
  * #source_location: 
    * file: main.c
    * line: 44
    * function: main
    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
  0: member
      * type: signedbv
          * width: 32
          * #c_type: signed_int
      * component_name: y
      * #source_location: 
        * file: main.c
        * line: 44
        * function: main
        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
      * #lvalue: 1
      0: index
          * type: symbol
              * identifier: tag-Ssub
              * #source_location: 
                * file: main.c
                * line: 9
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * #source_location: 
            * file: main.c
            * line: 44
            * function: main
            * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
          * #lvalue: 1
          0: member
              * type: array
                  * size: constant
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      * value: 0000000000000000000000000000000000000000000000000000000001100100
                  * #source_location: 
                    * file: main.c
                    * line: 12
                    * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
                  0: symbol
                      * identifier: tag-Ssub
                      * #source_location: 
                        * file: main.c
                        * line: 9
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              * component_name: array
              * #source_location: 
                * file: main.c
                * line: 44
                * function: main
                * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
              * #lvalue: 1
              0: integer_dereference
                  * type: symbol
                      * identifier: tag-S
                      * #source_location: 
                        * file: main.c
                        * line: 44
                        * function: main
                        * working_directory: /Users/kroening/progr/cbmc-git/regression/cbmc/offsetof1
                  0: constant
                      * type: signedbv
                          * width: 64
                          * #c_type: signed_long_int
                      * value: 0000000000000000000000000000000000000000000000000000000000000000
          1: constant
              * type: signedbv
                  * width: 64
                  * #c_type: signed_long_int
              * value: 0000000000000000000000000000000000000000000000000000000000000001
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
81 variables, 76 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 40 (out of 40)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 17 VCC(s), 8 remaining after simplification
Runtime total: 0.0792946s
Runtime decision procedure: 0.0114453s

** Results:
[main.assertion.1] assertion __builtin_offsetof(struct S, i)==0: SUCCESS
[main.assertion.2] assertion __builtin_offsetof(struct S, ch)==4: SUCCESS
[main.assertion.3] assertion __builtin_offsetof(struct S, j)==8: SUCCESS
[main.assertion.4] assertion __builtin_offsetof(struct S, sub.x)==12: SUCCESS
[main.assertion.5] assertion __builtin_offsetof(struct S, sub.y)==16: SUCCESS
[main.assertion.6] assertion __builtin_offsetof(struct S, array)==16+4: SUCCESS
[main.assertion.7] assertion __builtin_offsetof(struct S, array[1])==16+12: SUCCESS
[main.assertion.8] assertion __builtin_offsetof(struct S, array[1].y)==16+12+4: SUCCESS
[main.assertion.9] assertion __builtin_offsetof(struct S, array[ch].y)==16+4+4+ch*sizeof(struct Ssub): SUCCESS
[main.assertion.10] assertion (long int)&((struct S *)0)->i==0: FAILURE
[main.assertion.11] assertion (long int)&((struct S *)0)->ch==4: FAILURE
[main.assertion.12] assertion (long int)&((struct S *)0)->j==8: FAILURE
[main.assertion.13] assertion (long int)&((struct S *)0)->sub.x==12: FAILURE
[main.assertion.14] assertion (long int)&((struct S *)0)->sub.y==16: FAILURE
[main.assertion.15] assertion (long int)&((struct S *)0)->array==16+4: FAILURE
[main.assertion.16] assertion (long int)&((struct S *)0)->array[1]==16+12: FAILURE
[main.assertion.17] assertion (long int)&((struct S *)0)->array[1].y==16+12+4: FAILURE

** 8 of 17 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]
^warning: ignoring [FAILED]


Failed test: pipe1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
678 variables, 951 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2094 variables, 5601 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2094 variables, 5601 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2094 variables, 5601 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2136 variables, 5778 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2136 variables, 5778 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2136 variables, 5778 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2005 variables, 5170 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2006 variables, 5170 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2005 variables, 5170 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2005 variables, 5170 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2079 variables, 5533 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2080 variables, 5533 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2079 variables, 5533 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2079 variables, 5533 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1849 variables, 4598 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1849 variables, 4598 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1849 variables, 4598 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1849 variables, 4598 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1919 variables, 4917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1919 variables, 4917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1919 variables, 4917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1919 variables, 4917 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1735 variables, 4472 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1735 variables, 4472 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1735 variables, 4472 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1735 variables, 4472 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2032 variables, 5388 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2032 variables, 5388 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2032 variables, 5388 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2074 variables, 5565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2074 variables, 5565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2074 variables, 5565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1943 variables, 4957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1944 variables, 4957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1943 variables, 4957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1943 variables, 4957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2017 variables, 5320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2018 variables, 5320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2017 variables, 5320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2017 variables, 5320 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1787 variables, 4385 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1787 variables, 4385 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1787 variables, 4385 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1787 variables, 4385 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1857 variables, 4704 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1857 variables, 4704 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1857 variables, 4704 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1857 variables, 4704 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1673 variables, 4259 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1673 variables, 4259 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1673 variables, 4259 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1673 variables, 4259 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1481 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2811 variables, 8633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2811 variables, 8633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2811 variables, 8633 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2853 variables, 8810 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2853 variables, 8810 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2853 variables, 8810 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2722 variables, 8202 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2723 variables, 8202 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2722 variables, 8202 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2722 variables, 8202 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2796 variables, 8565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2797 variables, 8565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2796 variables, 8565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2796 variables, 8565 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2566 variables, 7630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2566 variables, 7630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2566 variables, 7630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2566 variables, 7630 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2636 variables, 7949 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2636 variables, 7949 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2636 variables, 7949 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2636 variables, 7949 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2468 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2468 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2468 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2468 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2661 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2735 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1277 variables, 3521 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2623 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2623 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2623 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2665 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2665 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2665 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2534 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2535 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2534 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2534 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2608 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2609 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2608 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2608 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2378 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2378 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2378 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2378 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2448 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2448 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2448 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2448 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2264 variables, 6816 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2264 variables, 6816 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2264 variables, 6816 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2264 variables, 6816 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2473 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2547 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1419 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2749 variables, 8420 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2791 variables, 8597 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2661 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2660 variables, 7989 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2735 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2734 variables, 8352 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2504 variables, 7417 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Queue 5 thread 1/1 PC 31 depth 110 [2480 steps, 1.01558s]
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2574 variables, 7736 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2406 variables, 4209 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2687 variables, 8207 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2687 variables, 8207 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2687 variables, 8207 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2729 variables, 8384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2729 variables, 8384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2729 variables, 8384 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2598 variables, 7776 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2599 variables, 7776 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2598 variables, 7776 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2598 variables, 7776 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2672 variables, 8139 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2673 variables, 8139 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2672 variables, 8139 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2672 variables, 8139 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2442 variables, 7204 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2442 variables, 7204 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2442 variables, 7204 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2442 variables, 7204 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2512 variables, 7523 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2512 variables, 7523 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2512 variables, 7523 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2512 variables, 7523 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2344 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2344 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2344 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2344 variables, 3996 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1215 variables, 3308 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2561 variables, 4650 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2603 variables, 4827 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2473 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2472 variables, 4219 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2547 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2546 variables, 4582 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2316 variables, 3647 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2386 variables, 3966 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2202 variables, 6603 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2499 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2499 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2499 variables, 4437 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2541 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2541 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2541 variables, 4614 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2410 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2411 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2410 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2410 variables, 4006 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2484 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2485 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2484 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2484 variables, 4369 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2254 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2254 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2254 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2254 variables, 3434 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2324 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2324 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2324 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2324 variables, 3753 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2140 variables, 6390 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2140 variables, 6390 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2140 variables, 6390 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2140 variables, 6390 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1254 variables, 3386 clauses
SAT checker: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2600 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2600 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2600 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2642 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2642 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2642 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2511 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2512 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2511 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2511 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2585 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2586 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2585 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2585 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2355 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2355 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2355 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2355 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2425 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2425 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2425 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2425 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2241 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2241 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2241 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2241 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2538 variables, 7428 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2538 variables, 7428 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2538 variables, 7428 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2580 variables, 7605 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2580 variables, 7605 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2580 variables, 7605 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2449 variables, 6988 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2450 variables, 6997 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2449 variables, 6988 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2449 variables, 6988 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2523 variables, 7351 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2524 variables, 7360 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2523 variables, 7351 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2523 variables, 7351 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2293 variables, 6416 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2293 variables, 6416 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2293 variables, 6416 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2293 variables, 6416 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2363 variables, 6735 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2363 variables, 6735 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2363 variables, 6735 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2363 variables, 6735 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2179 variables, 6290 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2179 variables, 6290 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2179 variables, 6290 clauses
SAT checker: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2179 variables, 6290 clauses
SAT checker: instance is UNSATISFIABLE
unexpected OTHER statement: array_replace
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.3
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.2
flatten_byte_update can only do arrays of scalars right now, but got symbol
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
2118 variables, 6823 clauses
SAT checker: instance is SATISFIABLE
Queue 7 thread 1/1 PC 85 depth 94 [4220 steps, 2.02417s]
unexpected OTHER statement: array_replace
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3378 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3378 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3378 variables, 3960 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3420 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3420 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3420 variables, 4137 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3289 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3290 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3289 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3289 variables, 3529 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3363 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3364 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3363 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3363 variables, 3892 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3133 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3133 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3133 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3133 variables, 2957 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3203 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3203 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3203 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3203 variables, 3276 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3035 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3035 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3035 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3035 variables, 2831 clauses
SAT checker inconsistent: instance is UNSATISFIABLE
Checking property main.assertion.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3316 variables, 10672 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3316 variables, 10672 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3316 variables, 10672 clauses
SAT checker: instance is SATISFIABLE
Checking property main.assertion.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
3227 variables, 10232 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 186 (out of 197)
Number of dropped states: 52
Number of paths: 93
Number of infeasible paths: 0
Generated 437 VCC(s), 391 remaining after simplification
Runtime total: 2.24467s
Runtime decision procedure: 1.80321s

** Results:
[main.assertion.1] assertion ret==2: FAILURE
[main.assertion.2] assertion ret==2: FAILURE
[main.assertion.3] assertion data[0]==7: FAILURE
[main.assertion.4] assertion data[1]==31: FAILURE
[main.assertion.5] assertion data[1]==42: FAILURE

** 5 of 5 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^\*\* 1 of 5 failed  [FAILED]


Failed test: pointer-function-parameters
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Instrumenting coverage goals
Rewriting existing assertions as assumptions
Starting symbolic simulation
Checking property fun.coverage.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
105 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
105 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
137 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
137 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
138 variables, 44 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 38 (out of 42)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 8 VCC(s), 5 remaining after simplification
Runtime total: 0.0028265s
Runtime decision procedure: 0.00205815s

** coverage results:
[fun.coverage.1] file main.c line 3 function fun entry point: SATISFIED
[fun.coverage.2] file main.c line 3 function fun block 1 branch false: SATISFIED
[fun.coverage.3] file main.c line 3 function fun block 1 branch true: SATISFIED
[fun.coverage.4] file main.c line 7 function fun block 3 branch false: SATISFIED
[fun.coverage.5] file main.c line 7 function fun block 3 branch true: SATISFIED

** 5 of 5 covered (100.0%)
Test suite:

EXIT=0
SIGNAL=0


Failed test.desc lines:
^a=\(\(signed int \*\)NULL\), tmp(\$\d+)?=[^,]*$ [FAILED]
^a=&tmp(\$\d+)?!0, tmp(\$\d+)?=4$ [FAILED]
^a=&tmp(\$\d+)?!0, tmp(\$\d+)?=([012356789][0-9]*|4[0-9]+)$ [FAILED]


Failed test: pointer-function-parameters-2
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Instrumenting coverage goals
Rewriting existing assertions as assumptions
Starting symbolic simulation
Checking property fun.coverage.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
169 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.2
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
169 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.3
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
170 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.4
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
170 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.5
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
202 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.6
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
202 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Checking property fun.coverage.7
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
203 variables, 44 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 50 (out of 54)
Number of dropped states: 0
Number of paths: 2
Number of infeasible paths: 0
Generated 15 VCC(s), 7 remaining after simplification
Runtime total: 0.00415918s
Runtime decision procedure: 0.00305726s

** coverage results:
[fun.coverage.1] file main.c line 3 function fun entry point: SATISFIED
[fun.coverage.2] file main.c line 3 function fun block 1 branch false: SATISFIED
[fun.coverage.3] file main.c line 3 function fun block 1 branch true: SATISFIED
[fun.coverage.4] file main.c line 7 function fun block 3 branch false: SATISFIED
[fun.coverage.5] file main.c line 7 function fun block 3 branch true: SATISFIED
[fun.coverage.6] file main.c line 11 function fun block 5 branch false: SATISFIED
[fun.coverage.7] file main.c line 11 function fun block 5 branch true: SATISFIED

** 7 of 7 covered (100.0%)
Test suite:

EXIT=0
SIGNAL=0


Failed test.desc lines:
^a=\(\(signed int \*\*\)NULL\), tmp(\$\d+)?=[^,]*, tmp(\$\d+)?=[^,]*$ [FAILED]
^a=&tmp(\$\d+)?!0, tmp(\$\d+)?=\(\(signed int \*\)NULL\), tmp(\$\d+)?=[^,]*$ [FAILED]
^a=&tmp(\$\d+)?!0, tmp(\$\d+)?=&tmp\$\d+!0, tmp(\$\d+)?=(-[0-9]+|[012356789][0-9]*|4[0-9]+)$ [FAILED]
^a=&tmp(\$\d+)?!0, tmp(\$\d+)?=&tmp(\$\d+)?!0, tmp(\$\d+)?=4$ [FAILED]


Failed test: printf1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property main.assertion.1
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
8 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Number of visited locations: 19 (out of 52)
Number of dropped states: 0
Number of paths: 0
Number of infeasible paths: 0
Generated 1 VCC(s), 1 remaining after simplification
Runtime total: 0.000663919s
Runtime decision procedure: 0.000355566s

** Results:
[main.assertion.1] assertion 0: FAILURE

Trace for main.assertion.1:

Violated property:
  file main.c line 10 function main
  assertion 0
  !((signed long int)!(0 != 0) != 0l)


** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^PRINT d1 123, -123$ [FAILED]
^PRINT g1 123, -123, 123\.123, 0\.123$ [FAILED]
^PRINT e1 1\.230000e\+2, -1\.230000e\+2, 1\.231230e\+2, 1\.230000e-1$ [FAILED]
^PRINT f1 123\.000000, -123\.000000, 123\.123000, 0\.123000$ [FAILED]


Failed test: reachability-slice
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --reachability-slice
EXIT=64
SIGNAL=0


Failed test.desc lines:
1001 [FAILED]


Failed test: reachability-slice
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --reachability-slice-fb
EXIT=64
SIGNAL=0


Failed test2.desc lines:
1001 [FAILED]
1002 [FAILED]
1003 [FAILED]
1005 [FAILED]


Failed test: reachability-slice
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --reachability-slice
EXIT=64
SIGNAL=0


Failed test3.desc lines:
1001 [FAILED]
1002 [FAILED]
1003 [FAILED]
1004 [FAILED]


Failed test: reachability-slice-interproc
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and in --classpath
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --reachability-slice-fb
EXIT=64
SIGNAL=0


Failed test.desc lines:
target_kept [FAILED]
reachable_before_target_caller_1_kept [FAILED]
reachable_after_target_caller_1_kept [FAILED]
reachable_may_call_target_1_kept [FAILED]
reachable_before_target_caller_2_kept [FAILED]
reachable_after_target_caller_2_kept [FAILED]
reachable_may_call_target_2_kept [FAILED]


Failed test: read1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Checking property read.pointer_dereference.9
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
1007 variables, 1808 clauses
SAT checker: instance is SATISFIABLE
unexpected OTHER statement: array_replace
Number of visited locations: 45 (out of 188)
Number of dropped states: 1
Number of paths: 0
Number of infeasible paths: 0
Generated 10 VCC(s), 1 remaining after simplification
Runtime total: 0.00572535s
Runtime decision procedure: 0.00386829s

** Results:
[read.pointer_dereference.1] dereference failure: pointer NULL in *((char *)buf): SUCCESS
[read.pointer_dereference.2] dereference failure: pointer invalid in *((char *)buf): SUCCESS
[read.pointer_dereference.3] dereference failure: deallocated dynamic object in *((char *)buf): SUCCESS
[read.pointer_dereference.4] dereference failure: dead object in *((char *)buf): SUCCESS
[read.pointer_dereference.5] dereference failure: pointer outside dynamic object bounds in *((char *)buf): SUCCESS
[read.pointer_dereference.6] dereference failure: pointer outside object bounds in *((char *)buf): SUCCESS
[read.pointer_dereference.7] dereference failure: invalid integer address in *((char *)buf): SUCCESS
[read.pointer_dereference.8] dereference failure: pointer outside dynamic object bounds in *(((const char *)buf + (signed long int)str_length) - (signed long int)1): SUCCESS
[read.pointer_dereference.9] dereference failure: pointer outside object bounds in *(((const char *)buf + (signed long int)str_length) - (signed long int)1): FAILURE
[read.pointer_dereference.10] dereference failure: invalid integer address in *(((const char *)buf + (signed long int)str_length) - (signed long int)1): SUCCESS
[read.array_bounds.1] array `__CPROVER_pipes' lower bound in __CPROVER_pipes[(signed long int)fildes]: SUCCESS
[read.array_bounds.2] array `__CPROVER_pipes' lower bound in __CPROVER_pipes[(signed long int)fildes]: SUCCESS
[read.pointer_dereference.11] dereference failure: pointer NULL in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.12] dereference failure: pointer invalid in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.13] dereference failure: deallocated dynamic object in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.14] dereference failure: dead object in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.15] dereference failure: pointer outside dynamic object bounds in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.16] dereference failure: pointer outside object bounds in ((char *)buf)[(signed long int)i]: SUCCESS
[read.pointer_dereference.17] dereference failure: invalid integer address in ((char *)buf)[(signed long int)i]: SUCCESS
[read.array_bounds.3] array `__CPROVER_pipes' lower bound in __CPROVER_pipes[(signed long int)fildes]: SUCCESS
[read.array_bounds.4] array `__CPROVER_pipes'[].data lower bound in __CPROVER_pipes[(signed long int)fildes].data[(signed long int)__CPROVER_pipes[(signed long int)fildes].next_unread]: SUCCESS
[read.array_bounds.5] array `__CPROVER_pipes'[].data upper bound in __CPROVER_pipes[(signed long int)fildes].data[(signed long int)__CPROVER_pipes[(signed long int)fildes].next_unread]: SUCCESS
[read.array_bounds.6] array `__CPROVER_pipes' lower bound in __CPROVER_pipes[(signed long int)fildes]: SUCCESS
[read.array_bounds.7] array `__CPROVER_pipes' lower bound in __CPROVER_pipes[(signed long int)fildes]: SUCCESS

** 1 of 24 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
\*\* 1 of .* failed \(.*\) [FAILED]


Failed test: realloc3
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 26 (out of 115)
Number of dropped states: 0
Number of paths: 1
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.000702679s
Runtime decision procedure: 0s

** Results:
[foo.precondition_instance.1] realloc argument is dynamic object: SUCCESS
[foo.assertion.1] assertion *(int*)x==42: SUCCESS

** 0 of 2 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=6$ [FAILED]
pointer handling for concurrency is unsound [FAILED]


Failed test: self_loops_to_assumptions1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Feasibility check
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
8 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Unwinding assertion failed: main.0
Number of visited locations: 16 (out of 22)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.000530005s
Runtime decision procedure: 0.000224171s

** Results:
[main.unwind.0] unwinding assertion loop 0: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed default.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: self_loops_to_assumptions1
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and in --classpath
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --no-self-loops-to-assumptions
EXIT=64
SIGNAL=0


Failed no-assume.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: strcat1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Number of visited locations: 99 (out of 117)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 8 VCC(s), 0 remaining after simplification
Runtime total: 0.00472262s
Runtime decision procedure: 0s

** Results:
[main.precondition_instance.1] strcat src/dst overlap: SUCCESS
[main.assertion.1] assertion A1[3] == 'd': SUCCESS
[main.assertion.2] assertion strlen(A1) == 4: SUCCESS
[main.precondition_instance.2] strncat src/dst overlap: SUCCESS
[main.assertion.3] assertion A2[3] == 'd': SUCCESS
[main.assertion.4] assertion strlen(A2) == 4: SUCCESS
[main.precondition_instance.3] strncat src/dst overlap: SUCCESS
[main.assertion.5] assertion A3[3] == '\0': SUCCESS
[main.assertion.6] assertion strlen(A3) == 4: SUCCESS

** 0 of 9 failed
VERIFICATION SUCCESSFUL
EXIT=0
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]
\[main.assertion.6\] assertion strlen\(A3\) == 4: FAILURE [FAILED]
\*\* 1 of 9 failed [FAILED]


Failed test: symex_should_exclude_null_pointers
Parsing main.c
Converting
Type-checking main
file main.c line 73 function main: function `assert' is not declared
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} !((1 & argc'#0) == 0)
{-33} deref3#1 == deref3#1
{-34} deref3#2 == ((1 & argc'#0) == 0 ? deref2 : x#1)
{-35} ptr4#1 == ptr4#1
{-36} ptr4#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-37} !((1 & argc'#0) == 0)
{-38} deref4#1 == deref4#1
{-39} deref4#2 == ((1 & argc'#0) == 0 ? deref3 : x#1)
{-40} ptr5#1 == ptr5#1
{-41} ptr5#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-42} !(!(argc'#0 == 5))
{-43} !((1 & argc'#0) == 0)
{-44} deref5#1 == deref5#1
{-45} deref5#2 == ((1 & argc'#0) == 0 ? deref4 : x#1)
{-46} ptr6#1 == ptr6#1
{-47} ptr6#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-48} !(!(argc'#0 == 6))
{-49} !((1 & argc'#0) == 0)
{-50} deref6#1 == deref6#1
{-51} deref6#2 == ((1 & argc'#0) == 0 ? deref5 : x#1)
{-52} ptr7#1 == ptr7#1
{-53} ptr7#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-54} !((1 & argc'#0) == 0)
{-55} ptr6#3 == ((signed int *)NULL)
{-56} deref7#1 == deref7#1
{-57} deref7#2 == ((1 & argc'#0) == 0 ? deref6 : x#1)
{-58} ptr8#1 == ptr8#1
{-59} ptr8#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-60} !((1 & argc'#0) == 0)
{-61} deref8#1 == deref8#1
{-62} deref8#2 == ((1 & argc'#0) == 0 ? deref7 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} !((1 & argc'#0) == 0)
{-33} deref3#1 == deref3#1
{-34} deref3#2 == ((1 & argc'#0) == 0 ? deref2 : x#1)
{-35} ptr4#1 == ptr4#1
{-36} ptr4#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-37} !((1 & argc'#0) == 0)
{-38} deref4#1 == deref4#1
{-39} deref4#2 == ((1 & argc'#0) == 0 ? deref3 : x#1)
{-40} ptr5#1 == ptr5#1
{-41} ptr5#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-42} !(!(argc'#0 == 5))
{-43} !((1 & argc'#0) == 0)
{-44} deref5#1 == deref5#1
{-45} deref5#2 == ((1 & argc'#0) == 0 ? deref4 : x#1)
{-46} ptr6#1 == ptr6#1
{-47} ptr6#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-48} !(argc'#0 == 6)
{-49} deref6#3 == deref6#3
{-50} deref6#4 == ((1 & argc'#0) == 0 ? deref9 : x#1)
{-51} ptr7#3 == ptr7#3
{-52} ptr7#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-53} !((1 & argc'#0) == 0)
{-54} ptr6#4 == ((signed int *)NULL)
{-55} deref7#3 == deref7#3
{-56} deref7#4 == ((1 & argc'#0) == 0 ? deref10 : x#1)
{-57} ptr8#3 == ptr8#3
{-58} ptr8#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-59} !((1 & argc'#0) == 0)
{-60} deref8#3 == deref8#3
{-61} deref8#4 == ((1 & argc'#0) == 0 ? deref11 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} !((1 & argc'#0) == 0)
{-33} deref3#1 == deref3#1
{-34} deref3#2 == ((1 & argc'#0) == 0 ? deref2 : x#1)
{-35} ptr4#1 == ptr4#1
{-36} ptr4#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-37} !((1 & argc'#0) == 0)
{-38} deref4#1 == deref4#1
{-39} deref4#2 == ((1 & argc'#0) == 0 ? deref3 : x#1)
{-40} ptr5#1 == ptr5#1
{-41} ptr5#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-42} !(argc'#0 == 5)
{-43} !((1 & argc'#0) == 0)
{-44} deref5#3 == deref5#3
{-45} deref5#4 == ((1 & argc'#0) == 0 ? deref13 : x#1)
{-46} ptr6#5 == ptr6#5
{-47} ptr6#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-48} !(!(argc'#0 == 6))
{-49} !((1 & argc'#0) == 0)
{-50} deref6#5 == deref6#5
{-51} deref6#6 == ((1 & argc'#0) == 0 ? deref14 : x#1)
{-52} ptr7#5 == ptr7#5
{-53} ptr7#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-54} !((1 & argc'#0) == 0)
{-55} ptr6#7 == ((signed int *)NULL)
{-56} deref7#5 == deref7#5
{-57} deref7#6 == ((1 & argc'#0) == 0 ? deref15 : x#1)
{-58} ptr8#5 == ptr8#5
{-59} ptr8#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-60} !((1 & argc'#0) == 0)
{-61} deref8#5 == deref8#5
{-62} deref8#6 == ((1 & argc'#0) == 0 ? deref16 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} !((1 & argc'#0) == 0)
{-33} deref3#1 == deref3#1
{-34} deref3#2 == ((1 & argc'#0) == 0 ? deref2 : x#1)
{-35} ptr4#1 == ptr4#1
{-36} ptr4#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-37} !((1 & argc'#0) == 0)
{-38} deref4#1 == deref4#1
{-39} deref4#2 == ((1 & argc'#0) == 0 ? deref3 : x#1)
{-40} ptr5#1 == ptr5#1
{-41} ptr5#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-42} !(argc'#0 == 5)
{-43} !((1 & argc'#0) == 0)
{-44} deref5#3 == deref5#3
{-45} deref5#4 == ((1 & argc'#0) == 0 ? deref13 : x#1)
{-46} ptr6#5 == ptr6#5
{-47} ptr6#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-48} !(argc'#0 == 6)
{-49} deref6#7 == deref6#7
{-50} deref6#8 == ((1 & argc'#0) == 0 ? deref18 : x#1)
{-51} ptr7#7 == ptr7#7
{-52} ptr7#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-53} !((1 & argc'#0) == 0)
{-54} ptr6#8 == ((signed int *)NULL)
{-55} deref7#7 == deref7#7
{-56} deref7#8 == ((1 & argc'#0) == 0 ? deref19 : x#1)
{-57} ptr8#7 == ptr8#7
{-58} ptr8#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-59} !((1 & argc'#0) == 0)
{-60} deref8#7 == deref8#7
{-61} deref8#8 == ((1 & argc'#0) == 0 ? deref20 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} (1 & argc'#0) == 0
{-33} ptr4#3 == ptr4#3
{-34} ptr4#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#3 == deref4#3
{-37} deref4#4 == ((1 & argc'#0) == 0 ? deref22 : x#1)
{-38} ptr5#3 == ptr5#3
{-39} ptr5#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(!(argc'#0 == 5))
{-41} !((1 & argc'#0) == 0)
{-42} deref5#5 == deref5#5
{-43} deref5#6 == ((1 & argc'#0) == 0 ? deref23 : x#1)
{-44} ptr6#9 == ptr6#9
{-45} ptr6#10 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(!(argc'#0 == 6))
{-47} !((1 & argc'#0) == 0)
{-48} deref6#9 == deref6#9
{-49} deref6#10 == ((1 & argc'#0) == 0 ? deref24 : x#1)
{-50} ptr7#9 == ptr7#9
{-51} ptr7#10 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-52} !((1 & argc'#0) == 0)
{-53} ptr6#11 == ((signed int *)NULL)
{-54} deref7#9 == deref7#9
{-55} deref7#10 == ((1 & argc'#0) == 0 ? deref25 : x#1)
{-56} ptr8#9 == ptr8#9
{-57} ptr8#10 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-58} !((1 & argc'#0) == 0)
{-59} deref8#9 == deref8#9
{-60} deref8#10 == ((1 & argc'#0) == 0 ? deref26 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} (1 & argc'#0) == 0
{-33} ptr4#3 == ptr4#3
{-34} ptr4#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#3 == deref4#3
{-37} deref4#4 == ((1 & argc'#0) == 0 ? deref22 : x#1)
{-38} ptr5#3 == ptr5#3
{-39} ptr5#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(!(argc'#0 == 5))
{-41} !((1 & argc'#0) == 0)
{-42} deref5#5 == deref5#5
{-43} deref5#6 == ((1 & argc'#0) == 0 ? deref23 : x#1)
{-44} ptr6#9 == ptr6#9
{-45} ptr6#10 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(argc'#0 == 6)
{-47} deref6#11 == deref6#11
{-48} deref6#12 == ((1 & argc'#0) == 0 ? deref28 : x#1)
{-49} ptr7#11 == ptr7#11
{-50} ptr7#12 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-51} !((1 & argc'#0) == 0)
{-52} ptr6#12 == ((signed int *)NULL)
{-53} deref7#11 == deref7#11
{-54} deref7#12 == ((1 & argc'#0) == 0 ? deref29 : x#1)
{-55} ptr8#11 == ptr8#11
{-56} ptr8#12 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-57} !((1 & argc'#0) == 0)
{-58} deref8#11 == deref8#11
{-59} deref8#12 == ((1 & argc'#0) == 0 ? deref30 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} (1 & argc'#0) == 0
{-33} ptr4#3 == ptr4#3
{-34} ptr4#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#3 == deref4#3
{-37} deref4#4 == ((1 & argc'#0) == 0 ? deref22 : x#1)
{-38} ptr5#3 == ptr5#3
{-39} ptr5#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(argc'#0 == 5)
{-41} !((1 & argc'#0) == 0)
{-42} deref5#7 == deref5#7
{-43} deref5#8 == ((1 & argc'#0) == 0 ? deref32 : x#1)
{-44} ptr6#13 == ptr6#13
{-45} ptr6#14 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(!(argc'#0 == 6))
{-47} !((1 & argc'#0) == 0)
{-48} deref6#13 == deref6#13
{-49} deref6#14 == ((1 & argc'#0) == 0 ? deref33 : x#1)
{-50} ptr7#13 == ptr7#13
{-51} ptr7#14 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-52} !((1 & argc'#0) == 0)
{-53} ptr6#15 == ((signed int *)NULL)
{-54} deref7#13 == deref7#13
{-55} deref7#14 == ((1 & argc'#0) == 0 ? deref34 : x#1)
{-56} ptr8#13 == ptr8#13
{-57} ptr8#14 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-58} !((1 & argc'#0) == 0)
{-59} deref8#13 == deref8#13
{-60} deref8#14 == ((1 & argc'#0) == 0 ? deref35 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} !((1 & argc'#0) == 0)
{-28} deref2#1 == deref2#1
{-29} deref2#2 == ((1 & argc'#0) == 0 ? deref1 : x#1)
{-30} ptr3#1 == ptr3#1
{-31} ptr3#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-32} (1 & argc'#0) == 0
{-33} ptr4#3 == ptr4#3
{-34} ptr4#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#3 == deref4#3
{-37} deref4#4 == ((1 & argc'#0) == 0 ? deref22 : x#1)
{-38} ptr5#3 == ptr5#3
{-39} ptr5#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(argc'#0 == 5)
{-41} !((1 & argc'#0) == 0)
{-42} deref5#7 == deref5#7
{-43} deref5#8 == ((1 & argc'#0) == 0 ? deref32 : x#1)
{-44} ptr6#13 == ptr6#13
{-45} ptr6#14 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(argc'#0 == 6)
{-47} deref6#15 == deref6#15
{-48} deref6#16 == ((1 & argc'#0) == 0 ? deref37 : x#1)
{-49} ptr7#15 == ptr7#15
{-50} ptr7#16 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-51} !((1 & argc'#0) == 0)
{-52} ptr6#16 == ((signed int *)NULL)
{-53} deref7#15 == deref7#15
{-54} deref7#16 == ((1 & argc'#0) == 0 ? deref38 : x#1)
{-55} ptr8#15 == ptr8#15
{-56} ptr8#16 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-57} !((1 & argc'#0) == 0)
{-58} deref8#15 == deref8#15
{-59} deref8#16 == ((1 & argc'#0) == 0 ? deref39 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} !((1 & argc'#0) == 0)
{-31} deref3#3 == deref3#3
{-32} deref3#4 == ((1 & argc'#0) == 0 ? deref41 : x#1)
{-33} ptr4#5 == ptr4#5
{-34} ptr4#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#5 == deref4#5
{-37} deref4#6 == ((1 & argc'#0) == 0 ? deref42 : x#1)
{-38} ptr5#5 == ptr5#5
{-39} ptr5#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(!(argc'#0 == 5))
{-41} !((1 & argc'#0) == 0)
{-42} deref5#9 == deref5#9
{-43} deref5#10 == ((1 & argc'#0) == 0 ? deref43 : x#1)
{-44} ptr6#17 == ptr6#17
{-45} ptr6#18 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(!(argc'#0 == 6))
{-47} !((1 & argc'#0) == 0)
{-48} deref6#17 == deref6#17
{-49} deref6#18 == ((1 & argc'#0) == 0 ? deref44 : x#1)
{-50} ptr7#17 == ptr7#17
{-51} ptr7#18 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-52} !((1 & argc'#0) == 0)
{-53} ptr6#19 == ((signed int *)NULL)
{-54} deref7#17 == deref7#17
{-55} deref7#18 == ((1 & argc'#0) == 0 ? deref45 : x#1)
{-56} ptr8#17 == ptr8#17
{-57} ptr8#18 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-58} !((1 & argc'#0) == 0)
{-59} deref8#17 == deref8#17
{-60} deref8#18 == ((1 & argc'#0) == 0 ? deref46 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} !((1 & argc'#0) == 0)
{-31} deref3#3 == deref3#3
{-32} deref3#4 == ((1 & argc'#0) == 0 ? deref41 : x#1)
{-33} ptr4#5 == ptr4#5
{-34} ptr4#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#5 == deref4#5
{-37} deref4#6 == ((1 & argc'#0) == 0 ? deref42 : x#1)
{-38} ptr5#5 == ptr5#5
{-39} ptr5#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(!(argc'#0 == 5))
{-41} !((1 & argc'#0) == 0)
{-42} deref5#9 == deref5#9
{-43} deref5#10 == ((1 & argc'#0) == 0 ? deref43 : x#1)
{-44} ptr6#17 == ptr6#17
{-45} ptr6#18 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(argc'#0 == 6)
{-47} deref6#19 == deref6#19
{-48} deref6#20 == ((1 & argc'#0) == 0 ? deref48 : x#1)
{-49} ptr7#19 == ptr7#19
{-50} ptr7#20 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-51} !((1 & argc'#0) == 0)
{-52} ptr6#20 == ((signed int *)NULL)
{-53} deref7#19 == deref7#19
{-54} deref7#20 == ((1 & argc'#0) == 0 ? deref49 : x#1)
{-55} ptr8#19 == ptr8#19
{-56} ptr8#20 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-57} !((1 & argc'#0) == 0)
{-58} deref8#19 == deref8#19
{-59} deref8#20 == ((1 & argc'#0) == 0 ? deref50 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} !((1 & argc'#0) == 0)
{-31} deref3#3 == deref3#3
{-32} deref3#4 == ((1 & argc'#0) == 0 ? deref41 : x#1)
{-33} ptr4#5 == ptr4#5
{-34} ptr4#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#5 == deref4#5
{-37} deref4#6 == ((1 & argc'#0) == 0 ? deref42 : x#1)
{-38} ptr5#5 == ptr5#5
{-39} ptr5#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(argc'#0 == 5)
{-41} !((1 & argc'#0) == 0)
{-42} deref5#11 == deref5#11
{-43} deref5#12 == ((1 & argc'#0) == 0 ? deref52 : x#1)
{-44} ptr6#21 == ptr6#21
{-45} ptr6#22 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(!(argc'#0 == 6))
{-47} !((1 & argc'#0) == 0)
{-48} deref6#21 == deref6#21
{-49} deref6#22 == ((1 & argc'#0) == 0 ? deref53 : x#1)
{-50} ptr7#21 == ptr7#21
{-51} ptr7#22 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-52} !((1 & argc'#0) == 0)
{-53} ptr6#23 == ((signed int *)NULL)
{-54} deref7#21 == deref7#21
{-55} deref7#22 == ((1 & argc'#0) == 0 ? deref54 : x#1)
{-56} ptr8#21 == ptr8#21
{-57} ptr8#22 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-58} !((1 & argc'#0) == 0)
{-59} deref8#21 == deref8#21
{-60} deref8#22 == ((1 & argc'#0) == 0 ? deref55 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} !((1 & argc'#0) == 0)
{-31} deref3#3 == deref3#3
{-32} deref3#4 == ((1 & argc'#0) == 0 ? deref41 : x#1)
{-33} ptr4#5 == ptr4#5
{-34} ptr4#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-35} !((1 & argc'#0) == 0)
{-36} deref4#5 == deref4#5
{-37} deref4#6 == ((1 & argc'#0) == 0 ? deref42 : x#1)
{-38} ptr5#5 == ptr5#5
{-39} ptr5#6 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-40} !(argc'#0 == 5)
{-41} !((1 & argc'#0) == 0)
{-42} deref5#11 == deref5#11
{-43} deref5#12 == ((1 & argc'#0) == 0 ? deref52 : x#1)
{-44} ptr6#21 == ptr6#21
{-45} ptr6#22 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-46} !(argc'#0 == 6)
{-47} deref6#23 == deref6#23
{-48} deref6#24 == ((1 & argc'#0) == 0 ? deref57 : x#1)
{-49} ptr7#23 == ptr7#23
{-50} ptr7#24 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-51} !((1 & argc'#0) == 0)
{-52} ptr6#24 == ((signed int *)NULL)
{-53} deref7#23 == deref7#23
{-54} deref7#24 == ((1 & argc'#0) == 0 ? deref58 : x#1)
{-55} ptr8#23 == ptr8#23
{-56} ptr8#24 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-57} !((1 & argc'#0) == 0)
{-58} deref8#23 == deref8#23
{-59} deref8#24 == ((1 & argc'#0) == 0 ? deref59 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} (1 & argc'#0) == 0
{-31} ptr4#7 == ptr4#7
{-32} ptr4#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-33} !((1 & argc'#0) == 0)
{-34} deref4#7 == deref4#7
{-35} deref4#8 == ((1 & argc'#0) == 0 ? deref61 : x#1)
{-36} ptr5#7 == ptr5#7
{-37} ptr5#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-38} !(!(argc'#0 == 5))
{-39} !((1 & argc'#0) == 0)
{-40} deref5#13 == deref5#13
{-41} deref5#14 == ((1 & argc'#0) == 0 ? deref62 : x#1)
{-42} ptr6#25 == ptr6#25
{-43} ptr6#26 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-44} !(!(argc'#0 == 6))
{-45} !((1 & argc'#0) == 0)
{-46} deref6#25 == deref6#25
{-47} deref6#26 == ((1 & argc'#0) == 0 ? deref63 : x#1)
{-48} ptr7#25 == ptr7#25
{-49} ptr7#26 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-50} !((1 & argc'#0) == 0)
{-51} ptr6#27 == ((signed int *)NULL)
{-52} deref7#25 == deref7#25
{-53} deref7#26 == ((1 & argc'#0) == 0 ? deref64 : x#1)
{-54} ptr8#25 == ptr8#25
{-55} ptr8#26 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-56} !((1 & argc'#0) == 0)
{-57} deref8#25 == deref8#25
{-58} deref8#26 == ((1 & argc'#0) == 0 ? deref65 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} (1 & argc'#0) == 0
{-31} ptr4#7 == ptr4#7
{-32} ptr4#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-33} !((1 & argc'#0) == 0)
{-34} deref4#7 == deref4#7
{-35} deref4#8 == ((1 & argc'#0) == 0 ? deref61 : x#1)
{-36} ptr5#7 == ptr5#7
{-37} ptr5#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-38} !(!(argc'#0 == 5))
{-39} !((1 & argc'#0) == 0)
{-40} deref5#13 == deref5#13
{-41} deref5#14 == ((1 & argc'#0) == 0 ? deref62 : x#1)
{-42} ptr6#25 == ptr6#25
{-43} ptr6#26 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-44} !(argc'#0 == 6)
{-45} deref6#27 == deref6#27
{-46} deref6#28 == ((1 & argc'#0) == 0 ? deref67 : x#1)
{-47} ptr7#27 == ptr7#27
{-48} ptr7#28 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-49} !((1 & argc'#0) == 0)
{-50} ptr6#28 == ((signed int *)NULL)
{-51} deref7#27 == deref7#27
{-52} deref7#28 == ((1 & argc'#0) == 0 ? deref68 : x#1)
{-53} ptr8#27 == ptr8#27
{-54} ptr8#28 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-55} !((1 & argc'#0) == 0)
{-56} deref8#27 == deref8#27
{-57} deref8#28 == ((1 & argc'#0) == 0 ? deref69 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} (1 & argc'#0) == 0
{-31} ptr4#7 == ptr4#7
{-32} ptr4#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-33} !((1 & argc'#0) == 0)
{-34} deref4#7 == deref4#7
{-35} deref4#8 == ((1 & argc'#0) == 0 ? deref61 : x#1)
{-36} ptr5#7 == ptr5#7
{-37} ptr5#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-38} !(argc'#0 == 5)
{-39} !((1 & argc'#0) == 0)
{-40} deref5#15 == deref5#15
{-41} deref5#16 == ((1 & argc'#0) == 0 ? deref71 : x#1)
{-42} ptr6#29 == ptr6#29
{-43} ptr6#30 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-44} !(!(argc'#0 == 6))
{-45} !((1 & argc'#0) == 0)
{-46} deref6#29 == deref6#29
{-47} deref6#30 == ((1 & argc'#0) == 0 ? deref72 : x#1)
{-48} ptr7#29 == ptr7#29
{-49} ptr7#30 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-50} !((1 & argc'#0) == 0)
{-51} ptr6#31 == ((signed int *)NULL)
{-52} deref7#29 == deref7#29
{-53} deref7#30 == ((1 & argc'#0) == 0 ? deref73 : x#1)
{-54} ptr8#29 == ptr8#29
{-55} ptr8#30 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-56} !((1 & argc'#0) == 0)
{-57} deref8#29 == deref8#29
{-58} deref8#30 == ((1 & argc'#0) == 0 ? deref74 : x#1)
|--------------------------
{1} FALSE

file main.c line 73 function main
assertion 0
{-1} __CPROVER_dead_object#1 == NULL
{-2} __CPROVER_deallocated#1 == NULL
{-3} __CPROVER_malloc_is_new_array#1 == FALSE
{-4} __CPROVER_malloc_object#1 == NULL
{-5} __CPROVER_malloc_size#1 == 0ul
{-6} __CPROVER_memory_leak#1 == NULL
{-7} __CPROVER_next_thread_id#1 == 0ul
{-8} __CPROVER_pipe_count#1 == 0u
{-9} __CPROVER_rounding_mode#1 == 0
{-10} __CPROVER_thread_id#1 == 0ul
{-11} __CPROVER_threads_exited#1 == ARRAY_OF(FALSE)
{-12} argc'#0 >= 1
{-13} !(argc'#0 >= 268435457)
{-14} argv'#1 == byte_update_little_endian(argv'#0, 8ul * (unsigned long int)argc'#0, ((char *)NULL), char *)
{-15} argc#1 == argc'#0
{-16} argv#1 == argv'
{-17} x#1 == x#1
{-18} maybe_null#1 == maybe_null#1
{-19} maybe_null#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-20} ptr1#1 == ptr1#1
{-21} ptr1#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-22} !((1 & argc'#0) == 0)
{-23} deref1#1 == deref1#1
{-24} deref1#2 == ((1 & argc'#0) == 0 ? deref0 : x#1)
{-25} ptr2#1 == ptr2#1
{-26} ptr2#2 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-27} (1 & argc'#0) == 0
{-28} ptr3#3 == ptr3#3
{-29} ptr3#4 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-30} (1 & argc'#0) == 0
{-31} ptr4#7 == ptr4#7
{-32} ptr4#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-33} !((1 & argc'#0) == 0)
{-34} deref4#7 == deref4#7
{-35} deref4#8 == ((1 & argc'#0) == 0 ? deref61 : x#1)
{-36} ptr5#7 == ptr5#7
{-37} ptr5#8 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-38} !(argc'#0 == 5)
{-39} !((1 & argc'#0) == 0)
{-40} deref5#15 == deref5#15
{-41} deref5#16 == ((1 & argc'#0) == 0 ? deref71 : x#1)
{-42} ptr6#29 == ptr6#29
{-43} ptr6#30 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-44} !(argc'#0 == 6)
{-45} deref6#31 == deref6#31
{-46} deref6#32 == ((1 & argc'#0) == 0 ? deref76 : x#1)
{-47} ptr7#31 == ptr7#31
{-48} ptr7#32 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-49} !((1 & argc'#0) == 0)
{-50} ptr6#32 == ((signed int *)NULL)
{-51} deref7#31 == deref7#31
{-52} deref7#32 == ((1 & argc'#0) == 0 ? deref77 : x#1)
{-53} ptr8#31 == ptr8#31
{-54} ptr8#32 == ((1 & argc'#0) == 0 ? ((signed int *)NULL) : &x)
{-55} !((1 & argc'#0) == 0)
{-56} deref8#31 == deref8#31
{-57} deref8#32 == ((1 & argc'#0) == 0 ? deref78 : x#1)
|--------------------------
{1} FALSE

Number of visited locations: 96 (out of 96)
Number of dropped states: 0
Number of paths: 16
Number of infeasible paths: 0
Generated 16 VCC(s), 16 remaining after simplification
Runtime total: 0.240365s
Runtime decision procedure: 0s
EXIT=0
SIGNAL=0


Failed test.desc lines:
ptr4\$object [FAILED]
ptr5\$object [FAILED]
ptr6\$object [FAILED]
ptr7\$object [FAILED]
ptr8\$object [FAILED]


Failed test: trace_options_json_extended
[Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and in --classpath
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --trace-json-extended

  {
    "program": "Symex 5.9 (cbmc-5.9-517-g80331d8a5)"
  }
]
EXIT=64
SIGNAL=0


Failed extended.desc lines:
^EXIT=10$ [FAILED]
rawLhs [FAILED]


Failed test: trace_options_json_extended
[
  {
    "program": "Symex 5.9 (cbmc-5.9-517-g80331d8a5)"
  },
  {
    "messageText": "Parsing test.c",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Converting",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Type-checking test",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Generating GOTO Program",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Generic Property Instrumentation",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Removal of function pointers and virtual functions",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Starting symbolic simulation",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Checking property main.assertion.1",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Post-processing",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Solving with MiniSAT 2.2.1 with simplifier",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "11158 variables, 23161 clauses",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "SAT checker: instance is SATISFIABLE",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of visited locations: 19 (out of 25)",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of dropped states: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of paths: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Number of infeasible paths: 0",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Generated 1 VCC(s), 1 remaining after simplification",
    "messageType": "STATUS-MESSAGE"
  },
  {
    "messageText": "Runtime total: 0.0541025s\nRuntime decision procedure: 0.0520589s",
    "messageType": "STATUS-MESSAGE"
  }--- begin invariant violation report ---
Invariant check failed
File symex_parse_options.cpp function show_trace line 542
Reason: Unreachable
Backtrace:
Backtraces not supported


--- end invariant violation report ---
EXIT=134
SIGNAL=0


Failed non-extended.desc lines:
^EXIT=10$ [FAILED]


Failed test: trace_show_code
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and in --classpath
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --trace-show-code
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
local = 1 [FAILED]
int a [FAILED]
int c [FAILED]
unsigned int b [FAILED]
a = 0; [FAILED]
c = -100; [FAILED]
function_to_call\(a\) [FAILED]
function_to_call\(c\) [FAILED]
a = return_value_function_to_call \+ return_value_function_to_call [FAILED]
function_to_call\(\(signed int\)b\) [FAILED]
b = \(unsigned int\)return_value_function_to_call [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: trace_show_function_calls
Usage error!


* *        Symex 5.9 (cbmc-5.9-517-g80331d8a5) 64-bit       * *
* *                    Daniel Kroening                      * *
* *                 University of Oxford                    * *
* *                 kroening@kroening.com                   * *

Usage:                       Purpose:

 symex [-?] [-h] [--help]     show help
 symex file.c ...             source file names

Analysis options:
 --show-properties            show the properties, but don't run analysis
 --property id                only check one specific property
 --stop-on-fail               stop analysis once a failed property is detected
 --trace                      give a counterexample trace for failed properties

Frontend options:
 -I path                      set include path (C/C++)
 -D macro                     define preprocessor macro (C/C++)
 --preprocess                 stop after preprocessing
 --16, --32, --64             set width of int
 --LP64, --ILP64, --LLP64,
   --ILP32, --LP32            set width of int, long and pointers
 --little-endian              allow little-endian word-byte conversions
 --big-endian                 allow big-endian word-byte conversions
 --unsigned-char              make "char" unsigned by default
 --show-parse-tree            show parse tree
 --show-symbol-table          show symbol table
 --show-goto-functions        show loaded goto program
 --list-goto-functions        list loaded goto functions
 --drop-unused-functions      drop functions trivially unreachable from main function
 --ppc-macos                  set MACOS/PPC architecture
 --mm model                   set memory model (default: sc)
 --arch                       set architecture (default: x86_64)
 --os                         set operating system (default: macos)
 --no-arch                    don't set up an architecture
 --no-library                 disable built-in abstract C library
 --round-to-nearest           IEEE floating point rounding mode (default)
 --round-to-plus-inf          IEEE floating point rounding mode
 --round-to-minus-inf         IEEE floating point rounding mode
 --round-to-zero              IEEE floating point rounding mode
 --function name              set main function name

Java Bytecode frontend options:
 --disable-uncaught-exception-check
                              ignore uncaught exceptions and errors
 --throw-assertion-error      throw java.lang.AssertionError on violated
                              assert statements instead of failing
                              at the location of the assert statement
 --throw-runtime-exceptions   make implicit runtime exceptions explicit
 --max-nondet-array-length N  limit nondet (e.g. input) array size to <= N
 --max-nondet-tree-depth N    limit size of nondet (e.g. input) object tree;
                              at level N references are set to null
 --java-assume-inputs-non-null
                              never initialize reference-typed parameter to the
                              entry point with null
 --java-max-vla-length N      limit the length of user-code-created arrays
 --java-cp-include-files r    regexp or JSON list of files to load
                              (with '@' prefix)
 --no-lazy-methods            load and translate all methods given on
                              the command line and in --classpath
                              Default is to load methods that appear to be
                              reachable from the --function entry point
                              or main class
                              Note that --show-symbol-table, --show-goto-functions
                              and --show-properties output are restricted to
                              loaded methods by default.
 --lazy-methods-extra-entry-point METHODNAME
                              treat METHODNAME as a possible program entry
                              point for the purpose of lazy method loading
                              METHODNAME can be a regex that will be matched
                              against all symbols. If missing a java:: prefix
                              will be added. If no descriptor is found, all
                              overloads of a method will also be added.

Program instrumentation options:
 --bounds-check               enable array bounds checks
 --pointer-check              enable pointer checks (always enabled for Java)
 --memory-leak-check          enable memory leak checks
 --div-by-zero-check          enable division by zero checks
 --signed-overflow-check      enable signed arithmetic over- and underflow checks
 --unsigned-overflow-check    enable arithmetic over- and underflow checks
 --pointer-overflow-check     enable pointer arithmetic over- and underflow checks
 --conversion-check           check whether values can be represented after type cast
 --undefined-shift-check      check shift greater than bit-width
 --float-overflow-check       check floating-point for +/-Inf
 --nan-check                  check floating-point for NaN
 --no-built-in-assertions     ignore assertions in built-in library
 --no-assertions              ignore user assertions
 --no-assumptions             ignore user assumptions
 --error-label label          check that label is unreachable

Symex options:
 --unwind nr                  unwind nr times
 --depth nr                   limit search depth
 --context-bound nr           limit number of context switches
 --branch-bound nr            limit number of branches taken
 --max-search-time s          limit search to approximately s seconds
 --dfs                        use depth first search
 --bfs                        use breadth first search
 --eager-infeasibility        query solver early to determine whether a path is infeasible before searching it

Other options:
 --version                    show version and exit
 --xml-ui                     use XML-formatted output
 --verbosity #                verbosity level

Unknown option: --trace-show-function-calls
EXIT=64
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
Function call: function_to_call \(depth 2\) [FAILED]
Function return: function_to_call \(depth 1\) [FAILED]
Function call: function_to_call \(depth 2\) [FAILED]
^VERIFICATION FAILED$ [FAILED]


Failed test: unwind_counters1
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
Feasibility check
Post-processing
Solving with MiniSAT 2.2.1 with simplifier
104 variables, 11 clauses
SAT checker: instance is SATISFIABLE
Unwinding assertion failed: main.0
Number of visited locations: 25 (out of 32)
Number of dropped states: 1
Number of paths: 1
Number of infeasible paths: 0
Generated 0 VCC(s), 0 remaining after simplification
Runtime total: 0.00132555s
Runtime decision procedure: 0.000407161s

** Results:
[main.unwind.0] unwinding assertion loop 0: FAILURE

** 1 of 1 failed
VERIFICATION FAILED
EXIT=10
SIGNAL=0


Failed test.desc lines:
^EXIT=0$ [FAILED]
^VERIFICATION SUCCESSFUL$ [FAILED]


Failed test: variable-access-to-constant-array
Parsing main.c
Converting
Type-checking main
Generating GOTO Program
Generic Property Instrumentation
Removal of function pointers and virtual functions
Starting symbolic simulation
EXIT=139
SIGNAL=0


Failed test.desc lines:
^EXIT=10$ [FAILED]
^VERIFICATION FAILED$ [FAILED]
